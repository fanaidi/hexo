<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/hexo/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/hexo/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/hexo/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/hexo/images/logo.svg" color="#222">

<link rel="stylesheet" href="/hexo/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;fanaidi.github.io&quot;,&quot;root&quot;:&quot;&#x2F;hexo&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;hexo&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.5.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:false,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}</script><script src="/hexo/js/config.js"></script>
<meta name="description" content="[TOC] 一. java四种访问权限修饰符">
<meta property="og:type" content="article">
<meta property="og:title" content="Java">
<meta property="og:url" content="https://fanaidi.github.io/hexo/2021/04/07/Java/index.html">
<meta property="og:site_name" content="FanAiDi&#39;s Blog">
<meta property="og:description" content="[TOC] 一. java四种访问权限修饰符">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ae01.alicdn.com/kf/Uf3729577a3f34eb0a05265e55268b54fh.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/606435eeb0e7d.jpg">
<meta property="og:image" content="https://www.hualigs.cn/image/606470e53327f.jpg">
<meta property="article:published_time" content="2021-04-07T12:06:21.000Z">
<meta property="article:modified_time" content="2021-04-12T03:09:16.956Z">
<meta property="article:author" content="Jiang Fan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ae01.alicdn.com/kf/Uf3729577a3f34eb0a05265e55268b54fh.jpg">


<link rel="canonical" href="https://fanaidi.github.io/hexo/2021/04/07/Java/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;fanaidi.github.io&#x2F;hexo&#x2F;2021&#x2F;04&#x2F;07&#x2F;Java&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;04&#x2F;07&#x2F;Java&#x2F;&quot;,&quot;title&quot;:&quot;Java&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Java | FanAiDi's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/hexo/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/hexo/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">FanAiDi's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/hexo/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/hexo/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/hexo/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/hexo/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/hexo/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-schedule"><a href="/hexo/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a></li>
        <li class="menu-item menu-item-sitemap"><a href="/hexo/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/hexo/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80-java%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">1.</span> <span class="nav-text">一. java四种访问权限修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9B%9B%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="nav-number">1.1.</span> <span class="nav-text">1.四种访问权限修饰符的范围</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C-final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">2.</span> <span class="nav-text">二. final关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">1.用来修饰一个类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.</span> <span class="nav-text">2.用来修饰一个方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="nav-number">2.3.</span> <span class="nav-text">3.用来修饰类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">三. 基本数据类型对应的包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-number">3.1.</span> <span class="nav-text">1.基本数据类型对应的包装类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-gt-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">3.2.</span> <span class="nav-text">2.基本数据类型 -&gt; 字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%97%E7%AC%A6%E4%B8%B2-gt-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.</span> <span class="nav-text">3.字符串 -&gt; 基本数据类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B-%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">四.集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-List"><span class="nav-number">4.1.</span> <span class="nav-text">1.List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Set"><span class="nav-number">4.2.</span> <span class="nav-text">2.Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Map"><span class="nav-number">4.3.</span> <span class="nav-text">3.Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-List%E5%92%8CSet%E6%80%BB%E7%BB%93"><span class="nav-number">4.4.</span> <span class="nav-text">4.List和Set总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94-%E6%B3%9B%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">五. 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-number">5.1.</span> <span class="nav-text">1.含有泛型的方法：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB%EF%BC%9A"><span class="nav-number">5.2.</span> <span class="nav-text">2.含有泛型的类：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.3.</span> <span class="nav-text">3.含有泛型的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="nav-number">5.4.</span> <span class="nav-text">4.泛型的通配符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%AE%9A"><span class="nav-number">5.5.</span> <span class="nav-text">5.泛型的限定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD-%E5%BC%82%E5%B8%B8"><span class="nav-number">6.</span> <span class="nav-text">六. 异常</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%BC%82%E5%B8%B8%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="nav-number">6.1.</span> <span class="nav-text">1.异常关系图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-throw"><span class="nav-number">6.2.</span> <span class="nav-text">2.throw</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-throws"><span class="nav-number">6.3.</span> <span class="nav-text">3.throws</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E4%BA%A4%E7%BB%99%E5%88%AB%E4%BA%BA%E5%A4%84%E7%90%86%EF%BC%89"><span class="nav-number">6.3.1.</span> <span class="nav-text">a.异常处理的第一种方式（交给别人处理）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E8%87%AA%E5%B7%B1%E5%A4%84%E7%90%86%EF%BC%89try%E2%80%A6catch"><span class="nav-number">6.3.2.</span> <span class="nav-text">b.异常处理的第二种方式（自己处理）try…catch</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">4.异常处理方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-finally%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">6.5.</span> <span class="nav-text">5.finally代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">6.6.</span> <span class="nav-text">6.异常的注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%AD%90%E7%88%B6%E7%B1%BB%E5%BC%82%E5%B8%B8"><span class="nav-number">6.7.</span> <span class="nav-text">7.子父类异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-number">6.8.</span> <span class="nav-text">8.自定义异常类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%83-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">七. 线程和进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="nav-number">7.1.</span> <span class="nav-text">1.并发和并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="nav-number">7.2.</span> <span class="nav-text">2.线程和进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">7.3.</span> <span class="nav-text">3.创建多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">7.3.1.</span> <span class="nav-text">a.创建多线程的第一种方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="nav-number">7.3.2.</span> <span class="nav-text">b.创建线程的第二种方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#c-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">7.3.3.</span> <span class="nav-text">c.匿名内部类方式实现线程的创建</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Thread%E5%92%8CRunable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.4.</span> <span class="nav-text">4.Thread和Runable的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">7.5.</span> <span class="nav-text">5.线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">7.5.1.</span> <span class="nav-text">1.线程安全</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">7.5.2.</span> <span class="nav-text">2.线程同步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">7.5.3.</span> <span class="nav-text">3.同步代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">7.5.4.</span> <span class="nav-text">4.同步方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Lock%E9%94%81"><span class="nav-number">7.5.5.</span> <span class="nav-text">5.Lock锁</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">7.6.</span> <span class="nav-text">6.线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A6%82%E8%BF%B0"><span class="nav-number">7.6.1.</span> <span class="nav-text">1.线程状态概述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E8%B0%83%E7%94%A8wait%E5%92%8Cnotify%E6%96%B9%E6%B3%95%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%BB%86%E8%8A%82"><span class="nav-number">7.7.</span> <span class="nav-text">7.调用wait和notify方法需要注意的细节</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">7.8.</span> <span class="nav-text">8.线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AB-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">八.Lambda表达式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.1.</span> <span class="nav-text">Lambda表达式的标准格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9C%81%E7%95%A5%E6%A0%BC%E5%BC%8F"><span class="nav-number">8.2.</span> <span class="nav-text">Lambda表达式的省略格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="nav-number">8.3.</span> <span class="nav-text">Lambda表达式的使用前提</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%9D-File%E7%B1%BB"><span class="nav-number">9.</span> <span class="nav-text">九.File类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">9.1.</span> <span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-File%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">9.2.</span> <span class="nav-text">2.File类的静态成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="nav-number">9.3.</span> <span class="nav-text">3.绝对路径和相对路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-File%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-number">9.4.</span> <span class="nav-text">4.File类的构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-File%E7%B1%BB%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.5.</span> <span class="nav-text">5.File类获取功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-File%E7%B1%BB%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.6.</span> <span class="nav-text">6.File类判断功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-File%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">9.7.</span> <span class="nav-text">7.File类创建删除功能的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-File%E7%B1%BB%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E5%8A%9F%E8%83%BD"><span class="nav-number">9.8.</span> <span class="nav-text">8.File类遍历目录功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0%E5%A4%9A%E7%BA%A7%E7%9B%AE%E5%BD%95-amp-%E6%90%9C%E7%B4%A2%E6%96%87%E4%BB%B6"><span class="nav-number">9.9.</span> <span class="nav-text">9.递归打印多级目录&amp;搜索文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-FileFilter%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="nav-number">9.10.</span> <span class="nav-text">10.FileFilter过滤器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8FileFilter-FilenameFilter%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6"><span class="nav-number">9.10.1.</span> <span class="nav-text">1.使用FileFilter|FilenameFilter获取指定文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81-IO%E6%B5%81"><span class="nav-number">10.</span> <span class="nav-text">十.IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-IO%E6%A6%82%E8%BF%B0"><span class="nav-number">10.1.</span> <span class="nav-text">1.IO概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">10.2.</span> <span class="nav-text">2.字节输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-FileOutputStream"><span class="nav-number">10.2.1.</span> <span class="nav-text">1.FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AD%97%E8%8A%82%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">10.3.</span> <span class="nav-text">3.字节输入流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileInputStream"><span class="nav-number">10.3.1.</span> <span class="nav-text">FileInputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="nav-number">10.4.</span> <span class="nav-text">4.字符流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Reader"><span class="nav-number">10.4.1.</span> <span class="nav-text">1.Reader</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-FileReader-%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">10.4.2.</span> <span class="nav-text">2.FileReader(文件字符输入流)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Writer"><span class="nav-number">10.4.3.</span> <span class="nav-text">3.Writer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-FileWriter%EF%BC%88%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%89"><span class="nav-number">10.4.4.</span> <span class="nav-text">4.FileWriter（文件字符输出流）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Properties%E9%9B%86%E5%90%88"><span class="nav-number">10.5.</span> <span class="nav-text">5.Properties集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">10.6.</span> <span class="nav-text">6.缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-BufferedOutputStream-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">10.6.1.</span> <span class="nav-text">1.BufferedOutputStream(字节缓冲输出流)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-BufferedInputStream-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">10.6.2.</span> <span class="nav-text">2.BufferedInputStream(字节缓冲输入流)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-BufferedWriter-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">10.6.3.</span> <span class="nav-text">3.BufferedWriter(字符缓冲输出流)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-BufferedReader"><span class="nav-number">10.6.4.</span> <span class="nav-text">4.BufferedReader</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">10.7.</span> <span class="nav-text">7.转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-OutputStreamWriter"><span class="nav-number">10.7.1.</span> <span class="nav-text">1.OutputStreamWriter</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-InputStreamReader"><span class="nav-number">10.7.2.</span> <span class="nav-text">2.InputStreamReader</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">10.8.</span> <span class="nav-text">8.序列化和反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-ObjectOutputStream"><span class="nav-number">10.8.1.</span> <span class="nav-text">1.ObjectOutputStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ObjectInputStream"><span class="nav-number">10.8.2.</span> <span class="nav-text">2.ObjectInputStream</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-transient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">10.8.3.</span> <span class="nav-text">3.transient关键字</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-PrintStream%EF%BC%88%E6%89%93%E5%8D%B0%E6%B5%81%EF%BC%89"><span class="nav-number">10.9.</span> <span class="nav-text">9.PrintStream（打印流）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%B8%80-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">11.</span> <span class="nav-text">十一.网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">11.1.</span> <span class="nav-text">1.软件结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">11.2.</span> <span class="nav-text">2.网络通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-TCP-IP%E5%8D%8F%E8%AE%AE"><span class="nav-number">11.2.1.</span> <span class="nav-text">1.TCP&#x2F;IP协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">11.2.2.</span> <span class="nav-text">2.协议的分类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="nav-number">11.3.</span> <span class="nav-text">3.网络编程三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E5%8D%8F%E8%AE%AE"><span class="nav-number">11.3.1.</span> <span class="nav-text">1.协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-IP%E5%9C%B0%E5%9D%80"><span class="nav-number">11.3.2.</span> <span class="nav-text">2.IP地址</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="nav-number">11.3.3.</span> <span class="nav-text">3.端口号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-TCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="nav-number">11.4.</span> <span class="nav-text">4.TCP通信程序</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="nav-number">11.4.1.</span> <span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-TCP%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">11.4.2.</span> <span class="nav-text">2.TCP通信的客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-TCP%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="nav-number">11.4.3.</span> <span class="nav-text">3.TCP通信的服务器端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%A1%88%E4%BE%8B"><span class="nav-number">11.4.4.</span> <span class="nav-text">4.文件上传案例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-%E6%A8%A1%E6%8B%9FBS%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">11.4.5.</span> <span class="nav-text">5.模拟BS服务器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%BA%8C-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.</span> <span class="nav-text">十二.函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-FunctionInterface%E6%B3%A8%E8%A7%A3"><span class="nav-number">12.1.</span> <span class="nav-text">1.FunctionInterface注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">12.2.</span> <span class="nav-text">2.函数式编程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-lambda%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="nav-number">12.2.1.</span> <span class="nav-text">1.lambda的延迟执行</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.3.</span> <span class="nav-text">3.常用的函数式接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Supplier"><span class="nav-number">12.3.1.</span> <span class="nav-text">1.Supplier</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-consumer"><span class="nav-number">12.3.2.</span> <span class="nav-text">2.consumer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Predicate"><span class="nav-number">12.3.3.</span> <span class="nav-text">3.Predicate</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Predicate%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95and"><span class="nav-number">12.3.3.1.</span> <span class="nav-text">1.Predicate接口中的默认方法and</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Predicate%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95or"><span class="nav-number">12.3.3.2.</span> <span class="nav-text">2.Predicate接口中的默认方法or</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-Predicate%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95negate"><span class="nav-number">12.3.3.3.</span> <span class="nav-text">3.Predicate接口中的默认方法negate</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-Predicate%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="nav-number">12.3.3.4.</span> <span class="nav-text">4.Predicate综合案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Function%E6%8E%A5%E5%8F%A3"><span class="nav-number">12.4.</span> <span class="nav-text">4.Function接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Function%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95andThen"><span class="nav-number">12.4.1.</span> <span class="nav-text">1.Function接口中的默认方法andThen</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%B8%89-Stream%E6%B5%81"><span class="nav-number">13.</span> <span class="nav-text">十三.Stream流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BD%BF%E7%94%A8Stream%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88"><span class="nav-number">13.1.</span> <span class="nav-text">1.使用Stream流的方式遍历集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%A4%E7%A7%8D%E8%8E%B7%E5%8F%96Stream%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">13.2.</span> <span class="nav-text">2.两种获取Stream流的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">13.3.</span> <span class="nav-text">3.常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-fouEach-%E9%80%90%E4%B8%80%E5%A4%84%E7%90%86"><span class="nav-number">13.3.1.</span> <span class="nav-text">1.fouEach(逐一处理)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-filter-%E8%BF%87%E6%BB%A4"><span class="nav-number">13.3.2.</span> <span class="nav-text">2.filter(过滤)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-map-%E6%98%A0%E5%B0%84"><span class="nav-number">13.3.3.</span> <span class="nav-text">3.map(映射)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-count-%E7%BB%9F%E8%AE%A1"><span class="nav-number">13.3.4.</span> <span class="nav-text">4.count(统计)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-limit-%E6%88%AA%E5%8F%96"><span class="nav-number">13.3.5.</span> <span class="nav-text">5.limit(截取)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-skip-%E8%B7%B3%E8%BF%87"><span class="nav-number">13.3.6.</span> <span class="nav-text">6.skip(跳过)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-concat"><span class="nav-number">13.3.7.</span> <span class="nav-text">7.concat</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E5%9B%9B-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="nav-number">14.</span> <span class="nav-text">十四.方法引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%AC%A6"><span class="nav-number">14.1.</span> <span class="nav-text">1.方法引用符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%80%9A%E8%BF%87%E5%AF%B9%E8%B1%A1%E5%90%8D%E5%BC%95%E7%94%A8%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">14.2.</span> <span class="nav-text">2.通过对象名引用成员方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%80%9A%E8%BF%87%E7%B1%BB%E5%90%8D%E5%BC%95%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="nav-number">14.3.</span> <span class="nav-text">3.通过类名引用静态成员方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%BA%94-Junit"><span class="nav-number">15.</span> <span class="nav-text">十五.Junit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="nav-number">15.1.</span> <span class="nav-text">1.测试分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="nav-number">15.2.</span> <span class="nav-text">2.使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-before-amp-after"><span class="nav-number">15.3.</span> <span class="nav-text">3.@before&amp;@after</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E5%85%AD-%E5%8F%8D%E5%B0%84"><span class="nav-number">16.</span> <span class="nav-text">十六.反射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">16.1.</span> <span class="nav-text">获取Class对象的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="nav-number">16.2.</span> <span class="nav-text">Class对象的功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%BB%AC"><span class="nav-number">16.2.1.</span> <span class="nav-text">1.获取成员变量们</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%BB%AC"><span class="nav-number">16.2.2.</span> <span class="nav-text">2.获取构造方法们</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E4%BB%AC"><span class="nav-number">16.2.3.</span> <span class="nav-text">3.获取成员方法们</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%90%8D"><span class="nav-number">16.2.4.</span> <span class="nav-text">4.获取类名</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%81%E4%B8%83-%E6%B3%A8%E8%A7%A3"><span class="nav-number">17.</span> <span class="nav-text">十七.注解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">18.</span> <span class="nav-text"></span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Jiang Fan"
      src="/hexo/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Jiang Fan</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/hexo/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://fanaidi.github.io/hexo/2021/04/07/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/hexo/images/avatar.jpg">
      <meta itemprop="name" content="Jiang Fan">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="FanAiDi's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-07 20:06:21" itemprop="dateCreated datePublished" datetime="2021-04-07T20:06:21+08:00">2021-04-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-04-12 11:09:16" itemprop="dateModified" datetime="2021-04-12T11:09:16+08:00">2021-04-12</time>
      </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>[TOC]</p>
<h3 id="一-java四种访问权限修饰符"><a href="#一-java四种访问权限修饰符" class="headerlink" title="一. java四种访问权限修饰符"></a>一. java四种访问权限修饰符</h3><span id="more"></span>

<h4 id="1-四种访问权限修饰符的范围"><a href="#1-四种访问权限修饰符的范围" class="headerlink" title="1.四种访问权限修饰符的范围"></a>1.四种访问权限修饰符的范围</h4><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>(default)</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一个包</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>子孙类</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>不同包非子类</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody></table>
<p>（说明：其中√表示可访问×表示不可访问 ，default为默认修饰符，并不是关键字，不用写）<br>四种修饰符按权限大小：public&gt;protected&gt;(default)&gt;private</p>
<h3 id="二-final关键字"><a href="#二-final关键字" class="headerlink" title="二. final关键字"></a>二. final关键字</h3><h4 id="1-用来修饰一个类"><a href="#1-用来修饰一个类" class="headerlink" title="1.用来修饰一个类"></a>1.用来修饰一个类</h4><p>如果引用为基本数据类型，则该引用为常量，该值无法修改；<br>如果引用为引用数据类型，比如对象、数组，则该对象、数组本身可以修改，但指向该对象或数组的地址的引用不能修改。<br>如果引用为类的成员变量，则必须当场赋值，否则编译会报错。</p>
<h4 id="2-用来修饰一个方法"><a href="#2-用来修饰一个方法" class="headerlink" title="2.用来修饰一个方法"></a>2.用来修饰一个方法</h4><p>当使用final修饰方法时，这个方法将成为最终方法，无法被子类重写。但是，该方法仍然可以被继承。</p>
<h4 id="3-用来修饰类"><a href="#3-用来修饰类" class="headerlink" title="3.用来修饰类"></a>3.用来修饰类</h4><p>当用final修改类时，该类成为最终类，无法被继承。简称为“断子绝孙类”。</p>
<h3 id="三-基本数据类型对应的包装类"><a href="#三-基本数据类型对应的包装类" class="headerlink" title="三. 基本数据类型对应的包装类"></a>三. 基本数据类型对应的包装类</h3><h4 id="1-基本数据类型对应的包装类"><a href="#1-基本数据类型对应的包装类" class="headerlink" title="1.基本数据类型对应的包装类"></a>1.基本数据类型对应的包装类</h4><table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
</tbody></table>
<h4 id="2-基本数据类型-gt-字符串"><a href="#2-基本数据类型-gt-字符串" class="headerlink" title="2.基本数据类型 -&gt; 字符串"></a>2.基本数据类型 -&gt; 字符串</h4><p>(1)基本数据类型的值+““（最简单的方式）<br>(2)使用包装类中的静态方法：static String toString(int i) 返回表示指定整数的 String对象。<br>(3)使用String类中的静态方法：static String valueOf(int i) 返回 int参数的字符串表示形式。 </p>
<h4 id="3-字符串-gt-基本数据类型"><a href="#3-字符串-gt-基本数据类型" class="headerlink" title="3.字符串 -&gt; 基本数据类型"></a>3.字符串 -&gt; 基本数据类型</h4><p>(1)使用包装类中的静态方法parseXX(“字符串”)<br>(2)static int parseInt(String s) 将字符串参数解析为带符号的十进制整数。<br>(3)static double parseDouble(String s) 返回一个新 double初始化为指定的代表的值 String ，如通过执行 valueOf类的方法 Double 。 </p>
<h3 id="四-集合"><a href="#四-集合" class="headerlink" title="四.集合"></a>四.集合</h3><h4 id="1-List"><a href="#1-List" class="headerlink" title="1.List"></a>1.List</h4><table>
<thead>
<tr>
<th></th>
<th>底层数据结构</th>
<th>查询速度</th>
<th>增删速度</th>
<th>线程安全</th>
<th>效率</th>
<th>是否可以存储重复元素</th>
</tr>
</thead>
<tbody><tr>
<td>ArrayList</td>
<td>数组</td>
<td>快</td>
<td>慢</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>LinkedList</td>
<td>链表</td>
<td>慢</td>
<td>快</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>Vector</td>
<td>数组</td>
<td>快</td>
<td>满</td>
<td>安全</td>
<td>低</td>
<td>可以</td>
</tr>
</tbody></table>
<p>（注意：Vector：它的方法上加了synchronized关键字，所以它是线程安全的，但也因此，它的效率很低，几乎已经被淘汰了。</p>
<p><strong>适用场景分析</strong>：当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。）</p>
<h4 id="2-Set"><a href="#2-Set" class="headerlink" title="2.Set"></a>2.Set</h4><table>
<thead>
<tr>
<th></th>
<th>底层数据结构</th>
<th>元素顺序</th>
<th>线程安全</th>
<th>效率</th>
<th>是否可以存储null元素</th>
</tr>
</thead>
<tbody><tr>
<td>HashSet</td>
<td>哈希表</td>
<td>无序</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>链表和哈希表共同实现</td>
<td>有序</td>
<td>不安全</td>
<td>高</td>
<td>可以</td>
</tr>
<tr>
<td>TreeSet</td>
<td>二叉树</td>
<td>无序</td>
<td></td>
<td></td>
<td>不可以</td>
</tr>
</tbody></table>
<p>（注意：HashSet：元素的唯一性是靠所存储元素类型是否重写hashCode()和equals()方法来保证的，如果没有重写这两个方法，则无法保证元素的唯一性.</p>
<p>TreeSet:元素唯一且已经排好序；唯一性同样需要重写</p>
<p>LinkedHashSet：是HashSet的子类，链表保证元素的添加顺序，哈希表保证元素的唯一性。</p>
<p><strong>适用场景分析</strong>：HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的Set，我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。）</p>
<h4 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h4><p>Map用于保存具有映射关系的数据，Map里保存着两组数据：key和value，它们都可以使任何引用类型的数据，但key不能重复。所以通过指定的key就可以取出对应的value。</p>
<table>
<thead>
<tr>
<th></th>
<th>key值是否有序</th>
<th>key值是否排序</th>
<th>key值是否排序</th>
<th>key值是否可以为NULL</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>TreeMap</td>
<td>否</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<p>（注意：存入TreeMap中的元素要么实现了Comparatable接口；要么使用Comparator接口作为构造参数创建Set对象。）</p>
<p><strong>适用场景分析</strong>：如果更新时不需要保持元素的顺序，就使用HashMap，如果需要保持元素的插入顺序或者访问顺序，就使用LinkedHashMap，如果需要使图按照键值排序，就使用TreeMap。</p>
<p>HashMap：适用于Map中插入、删除和定位元素。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p>
<h4 id="4-List和Set总结"><a href="#4-List和Set总结" class="headerlink" title="4.List和Set总结"></a>4.List和Set总结</h4><p>1.List,Set都是继承自Collection接口，Map则不是<br>2.List特点：元素有放入顺序，元素可重复 ，Set特点：元素无放入顺序，元素不可重复，重复元素会覆盖掉，（注意：元素虽然无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的，加入Set 的Object必须定义equals()方法 ，另外list支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。）<br>3.Set和List对比：<br>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。<br>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。<br>4.ArrayList与LinkedList的区别和适用场景<br>Arraylist：<br>优点：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。<br>缺点：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p>
<p>LinkedList：<br>优点：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景<br>缺点：因为LinkedList要移动指针,所以查询操作性能比较低。</p>
<p><strong>适用场景分析</strong>：<br>当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</p>
<h3 id="五-泛型"><a href="#五-泛型" class="headerlink" title="五. 泛型"></a>五. 泛型</h3><h4 id="1-含有泛型的方法："><a href="#1-含有泛型的方法：" class="headerlink" title="1.含有泛型的方法："></a>1.含有泛型的方法：</h4><p>格式：修饰符 &lt;泛型&gt; 返回值类型 方法名（参数列表（可以使用泛型））{}<br>或 修饰符 static &lt;泛型&gt; 返回值类型 方法名（参数列表（可以使用泛型））{}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//含有泛型的普通方法</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        System.out.println(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//含有泛型的静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;M&gt; <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">(M m)</span></span>&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-含有泛型的类："><a href="#2-含有泛型的类：" class="headerlink" title="2.含有泛型的类："></a>2.含有泛型的类：</h4><p>格式：修饰符 class 类名&lt;泛型&gt;{}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">含有泛型的类：变量的类型是泛型，方法的参数类型和返回值类型也是泛型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericClass</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> E name;</span><br><span class="line"><span class="keyword">private</span> E password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">GenericClass</span><span class="params">(E name, E password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(E name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(E password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-含有泛型的接口"><a href="#3-含有泛型的接口" class="headerlink" title="3.含有泛型的接口"></a>3.含有泛型的接口</h4><p>格式：修饰符 interface 接口名&lt;泛型&gt;{}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">含有泛型的接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IGeneric</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span> </span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">含有泛型的接口的实现类：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第一种表示方式：实现接口，并指定泛型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericImp1</span> <span class="keyword">implements</span> <span class="title">IGeneric</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">含有接口的实现类：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二种表示方式：接口使用什么类型，实现类就使用什么类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">就相当于定义了一个含有泛型的类，创建对象时指定泛型的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericImp2</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">IGeneric</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-泛型的通配符"><a href="#4-泛型的通配符" class="headerlink" title="4.泛型的通配符"></a>4.泛型的通配符</h4><p>如果不知道数据类型，可以用？代替，只能在传参的时候使用通配符，定义的时候不能使用通配符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">泛型通配符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTpf</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">    arrayList.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    arrayList1.add(<span class="number">1</span>);</span><br><span class="line">    arrayList1.add(<span class="number">2</span>);</span><br><span class="line">    printArray(arrayList);</span><br><span class="line">    printArray(arrayList1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(ArrayList&lt;?&gt; arrayList)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用迭代器遍历</span></span><br><span class="line">    Iterator&lt;?&gt; it = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">        <span class="comment">//it.next()方法，取出的元素是Object类型</span></span><br><span class="line">        Object next = it.next();</span><br><span class="line">        System.out.println(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-泛型的限定"><a href="#5-泛型的限定" class="headerlink" title="5.泛型的限定"></a>5.泛型的限定</h4><p>泛型的上限限定：？extends E 代表使用的泛型只能是E类型的子类或本身<br>泛型的下限限定：? super E 代表使用的泛型只能是E类型的父类或本身</p>
<h3 id="六-异常"><a href="#六-异常" class="headerlink" title="六. 异常"></a>六. 异常</h3><h4 id="1-异常关系图"><a href="#1-异常关系图" class="headerlink" title="1.异常关系图"></a>1.异常关系图</h4><p><img src="https://ae01.alicdn.com/kf/Uf3729577a3f34eb0a05265e55268b54fh.jpg" alt="异常"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> exception;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//编译期异常，进行编码（写代码），程序出现异常</span></span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;YYYY-MM-DD&quot;</span>);</span><br><span class="line">        Date date = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            date = simpleDateFormat.parse(<span class="string">&quot;1999-11&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        System.out.println(<span class="string">&quot;后续代码&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//运行期异常，Java程序运行过程中出现的错误</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">OutOfMemoryError 内存溢出错误，后续代码不会执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;后续代码&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-throw"><a href="#2-throw" class="headerlink" title="2.throw"></a>2.throw</h4><p>格式：throw new xxxException(“异常产生的原因”);<br>作用：使用throw关键字在指定的方法中抛出指定的异常<br>注意：throw关键字必须写在方法的内部<br>     throw关键字后面new的对象必须是Exception或者Exception的子类<br>     throw关键字抛出指定的异常对象，我们就必须处理这个异常对象<br>     throw关键字后面创建的是RuntimeException或RuntimeException的子类对象，我们可以不处理，默认交给JVM处理（打印异常对象，中断程序）<br>     throw关键字后面创建的编译异常（写代码的时候报错），我们就必须处理这个异常，要么throws，要么try…catch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = null;</span></span><br><span class="line"><span class="comment">//        test001(arr,0);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------------------------&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        test001(arr2,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//传入一个数组和下标，输出指定的值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test001</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对传入的arr进行合法性校验</span></span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;数组为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对传入的index进行合法性校验</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;<span class="number">0</span> || index &gt;arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;数组溢出&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用Objects.requireNonNull()方法对参数进行合法性判断（判断参数是否为NULL）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test001(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test001</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(o,<span class="string">&quot;传入的值不能为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-throws"><a href="#3-throws" class="headerlink" title="3.throws"></a>3.throws</h4><p>格式：在方法声明时使用<br>修饰符 返回值类型 方法名（参数列表） throws AAAException,BBBException…{<br>throw new AAAException(“产生原因”);<br>throw new BBBException(“产生原因”);<br>}<br>作用：当方法内部抛出异常对象的时候，那么我们就必须处理这个异常对象<br>            可以使用throws关键字处理异常对象，会把异常对象声明抛出给方法的调用者处（自己不处理，让别人处理），最终交给JVM处理（中断处理）<br>注意：(1).throws关键字必须写在方法声明处<br>            (2).throws关键字后面声明的异常必须是Exception或Exception的子类<br>            (3).方法内部如果抛出了多个异常对象，那么throws后面也必须声明多个异常。如果抛出的异常有子父类关系，那么直接声明父类异常即可。<br>            (4).调用了一个声明抛出异常的方法，我们就必须处理声明的异常。要么继续使用throws声明抛出，交给方法的调用者处理，最终交给JVM。要么try…catch..自己处理</p>
<h5 id="a-异常处理的第一种方式（交给别人处理）"><a href="#a-异常处理的第一种方式（交给别人处理）" class="headerlink" title="a.异常处理的第一种方式（交给别人处理）"></a>a.异常处理的第一种方式（交给别人处理）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line">   <span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest</span> </span>&#123;</span><br><span class="line">       <span class="comment">//FileNotFoundException extends IOException</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">           test001(<span class="string">&quot;c://a.tx&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断文件路径的合法性</span></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test001</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">           <span class="comment">//判断路径</span></span><br><span class="line">           <span class="keyword">if</span>(!fileName.equals(<span class="string">&quot;c://a.txt&quot;</span>))&#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;找不到c:/a.txt&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">&quot;找到了&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h5 id="b-异常处理的第二种方式（自己处理）try…catch"><a href="#b-异常处理的第二种方式（自己处理）try…catch" class="headerlink" title="b.异常处理的第二种方式（自己处理）try…catch"></a>b.异常处理的第二种方式（自己处理）try…catch</h5><p>格式：<br>try{<br>可能产生异常的代码<br>}catch(定义一个异常的变量，用来接收try中接收的异常对象){<br>异常的处理逻辑，获取异常对象后，怎么处理异常对象<br>一般在工作中，会把异常的信息记录到日志中<br>}<br>…<br>catch(异常类型名 变量名){</p>
<p>}<br>注意：(1).try中可能会抛出多个异常对象，那么就可以使用多个catch处理这些异常对象<br>           (2).如果try中产生了异常，就会执行catch中的异常处理逻辑，执行完毕catch中的异常处理逻辑，就会执行try…catch之后的代码。<br>           (3).如果try中没有产生异常，就不会执行catch中的异常处理逻辑。执行完try中的代码，继续执行try…catch之后的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//FileNotFoundException extends IOException</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//可能产生异常的代码</span></span><br><span class="line">            test001(<span class="string">&quot;c://a.tx&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">//try中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常变量</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后续代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后续代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断文件路径的合法性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test001</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">        <span class="comment">//判断路径</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.equals(<span class="string">&quot;c://a.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;找不到c:/a.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-异常处理方法"><a href="#4-异常处理方法" class="headerlink" title="4.异常处理方法"></a>4.异常处理方法</h4><p>getMessage() 返回此可抛出的简短描述。<br>toString() 返回此throwable的详细消息字符串。<br>printStackTrace() 将此throwable和其追溯打印到标准错误流。（JVM打印异常对象，默认此方法，打印的异常信息是最全面的） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//FileNotFoundException extends IOException</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//可能产生异常的代码</span></span><br><span class="line">            test001(<span class="string">&quot;c://a.txt&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">//try中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常变量</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            e.getMessage();</span><br><span class="line">            System.out.println(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后续代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后续代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断文件路径的合法性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test001</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">        <span class="comment">//判断路径</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.equals(<span class="string">&quot;c://a.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;找不到c:/a.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test002</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//判断后缀是不是.txt结尾</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;文件不是以.txt结尾&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-finally代码块"><a href="#5-finally代码块" class="headerlink" title="5.finally代码块"></a>5.finally代码块</h4><p>格式：try{<br>可能产生异常的代码<br>}catch(定义一个异常的变量，用来接收try中接收的异常对象){<br>异常的处理逻辑，获取异常对象后，怎么处理异常对象<br>一般在工作中，会把异常的信息记录到日志中<br>}finall{<br>无论是否出现异常都会执行<br>}<br>注意：(1).finally不能单独使用，必须和try一起使用<br>            (2).finally一般用于资源释放，无论程序是否出现异常，都要释放资源（IO）<br>            (3).如果finally有return语句，永远返回finally里面的结果，避免该情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowsTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//FileNotFoundException extends IOException</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//可能产生异常的代码</span></span><br><span class="line">            test002(<span class="string">&quot;c://a.tx&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;<span class="comment">//try中抛出什么异常对象，catch就定义什么异常变量，用来接收这个异常变量</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line"><span class="comment">//            e.getMessage();</span></span><br><span class="line"><span class="comment">//            System.out.println(e.toString());</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;释放资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后续代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后续代码&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断文件路径的合法性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test001</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> FileNotFoundException,IOException</span>&#123;</span><br><span class="line">        <span class="comment">//判断路径</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.equals(<span class="string">&quot;c://a.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;找不到c:/a.txt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test002</span><span class="params">(String fileName)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//判断后缀是不是.txt结尾</span></span><br><span class="line">        <span class="keyword">if</span>(!fileName.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;文件不是以.txt结尾&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-异常的注意事项"><a href="#6-异常的注意事项" class="headerlink" title="6.异常的注意事项"></a>6.异常的注意事项</h4><p>(1).多个异常分别处理<br>(2).多个异常一次捕获，多次处理（注意：catch里面定义的异常变量，如果有子父类关系，那么子类的异常变量必须在上面，否则就会报错<br>ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException）<br>解析：try中如果出现了异常对象，会把异常对象抛出给catch处理，抛出的异常对象会从上往下依次赋值给catch中定义的异常变量。如果上面是父类的异常对象，抛出的异常对象都会赋值给父类的异常对象，子类的异常对象就不会被使用。（多态）<br>(3).一次捕获，一次处理（运行时异常被抛出可以不处理，即不捕获也不声明，默认给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再继续执行）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptiZhuYi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多个异常分别处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);<span class="comment">//ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));<span class="comment">//IndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多个异常一次捕获，多次处理</span></span><br><span class="line">        <span class="comment">//ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);<span class="comment">//ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));<span class="comment">//IndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一次捕获，一次处理</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">            System.out.println(arr[<span class="number">3</span>]);<span class="comment">//ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">            List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            System.out.println(list.get(<span class="number">3</span>));<span class="comment">//IndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//运行时异常被抛出可以不处理，即不捕获也不声明</span></span><br><span class="line">        <span class="comment">//默认给虚拟机处理，终止程序，什么时候不抛出运行时异常了，再继续执行</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        System.out.println(arr[<span class="number">3</span>]);<span class="comment">//ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">        List&lt;Integer&gt; list = List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">3</span>));<span class="comment">//IndexOutOfBoundsException: Index 3 out of bounds for length 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-子父类异常"><a href="#7-子父类异常" class="headerlink" title="7.子父类异常"></a>7.子父类异常</h4><p>  (1)如果父类抛出了多个异常，子类重写父类方法时，抛出和父类相同的异常或父类异常的子类或不抛出<br>  (2)父类方法没有抛出异常，子类重写父类方法时也不能抛出异常。此时子类产生该异常，只能捕获处理，不能声明抛出。<br>  注意：父类什么样子，子类就什么样子</p>
<h4 id="8-自定义异常类"><a href="#8-自定义异常类" class="headerlink" title="8.自定义异常类"></a>8.自定义异常类</h4><p>格式: public class xxxException extends Exception|RuntimeException{<br> 添加一个空参数的构造方法<br> 添加一个带异常信息的构造方法<br> }<br> 注意：(1).自定义异常类一般是以Exception结尾，说明该类是一个异常类<br>            (2).自定义异常类必须继承Exception或RuntimeException<br>            (3).继承Exception：要么自定义的异常类就是一个编译器异常类，如果方法内部抛出了编译器异常，就必须处理这个异常，要么throws，要么try..catch<br>            (4).继承RuntimeException: 要么自定义的异常类就是一个运行期异常，无需处理，交给虚拟机处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegisterException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RegisterException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="七-线程和进程"><a href="#七-线程和进程" class="headerlink" title="七. 线程和进程"></a>七. 线程和进程</h3><h4 id="1-并发和并行"><a href="#1-并发和并行" class="headerlink" title="1.并发和并行"></a>1.并发和并行</h4><p>并发：交替执行<br>并行：同时执行</p>
<h4 id="2-线程和进程"><a href="#2-线程和进程" class="headerlink" title="2.线程和进程"></a>2.线程和进程</h4><p>线程：是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>进程：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<h4 id="3-创建多线程"><a href="#3-创建多线程" class="headerlink" title="3.创建多线程"></a>3.创建多线程</h4><h5 id="a-创建多线程的第一种方式："><a href="#a-创建多线程的第一种方式：" class="headerlink" title="a.创建多线程的第一种方式："></a>a.创建多线程的第一种方式：</h5><p>​    1.创建Thread类的子类</p>
<p>​    2.在Thread类的子类中重写Thread类的run方法，设置线程任务</p>
<p>​    3.创建Thread类的子类对象</p>
<p>​    4.调用Thread类的start方法，开启新的线程，执行run方法</p>
<p>​    注意：</p>
<p>​    public void start()</p>
<p>​    导致此线程开始执行;Java虚拟机调用此线程的<code>run</code>方法。</p>
<p>​    结果是两个线程同时运行：当前线程（从调用返回到start方法）和另一个线程（执行其run方法）。 </p>
<p>​    不止一次启动线程是不合法的。 特别地，一旦线程完成执行就可能不会重新启动。 </p>
<h5 id="b-创建线程的第二种方式："><a href="#b-创建线程的第二种方式：" class="headerlink" title="b.创建线程的第二种方式："></a>b.创建线程的第二种方式：</h5><p>​    1.创建runable接口的实现类</p>
<p>​    2.在实现类中重写runable接口的run方法 ，设置线程任务</p>
<p>​    3.创建runable接口的实现类对象</p>
<p>​    4.创建Thread类对象，构造方法中传递runable接口的实现类对象</p>
<p>​    5.调用Thread类对象的start方法，开启新线程执行run方法</p>
<h5 id="c-匿名内部类方式实现线程的创建"><a href="#c-匿名内部类方式实现线程的创建" class="headerlink" title="c.匿名内部类方式实现线程的创建"></a>c.匿名内部类方式实现线程的创建</h5><p>​    匿名内部类作用：简化代码</p>
<p>​    解析：把子类继承父类，重写父类的方法，创建子类对象合一步完成。</p>
<p>​                把实现类实现接口，重写接口中的方法，创建实现类对象合成一步完成。</p>
<p>​    匿名内部类的最终产物：子类/实现类对象，而这个类没有名字。</p>
<p>格式：new 父类/接口（）{</p>
<p>​    重写父类/接口中的方法</p>
<p>}</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.company.threadTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程的父类Thread</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="comment">//重写run方法，设置线程任务</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//线程的接口Runnable</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  &quot;</span>+i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-Thread和Runable的区别"><a href="#4-Thread和Runable的区别" class="headerlink" title="4.Thread和Runable的区别"></a>4.Thread和Runable的区别</h4><p>​    实现Runnable接口创建多线程的好处：</p>
<p>​    1.避免了单线程的局限性（实现Runnable接口，还可以继承其他类，实现其他接口）</p>
<p>​    2.增强程序的扩展性，降低程序的耦合性（实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离。实现类中重写了run方法：用来设置线程任务。创建Thread类对象，调用start方法，开启新的线程执行run方法）</p>
<h4 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5.线程安全"></a>5.线程安全</h4><h5 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1.线程安全"></a>1.线程安全</h5><ul>
<li>单线程程序是不会出现安全问题的</li>
<li>多线程程序，没有访问共享数据，不会产生问题</li>
<li>多线程访问了共享的数据，会产生线程安全问题</li>
</ul>
<h5 id="2-线程同步"><a href="#2-线程同步" class="headerlink" title="2.线程同步"></a>2.线程同步</h5><p>有三种方式完成同步操作：</p>
<ul>
<li>同步代码块</li>
<li>同步方法</li>
<li>锁机制</li>
</ul>
<h5 id="3-同步代码块"><a href="#3-同步代码块" class="headerlink" title="3.同步代码块"></a>3.同步代码块</h5><p>synchronized关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步锁：对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁。</p>
<p>1.锁对象可以是任意类型</p>
<p>2.多个线程对象 要使用同一把锁。</p>
<p>（注意：在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外面等着（BLOCKED））</p>
<h5 id="4-同步方法"><a href="#4-同步方法" class="headerlink" title="4.同步方法"></a>4.同步方法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">修饰符 synchronized 返回值类型 方法名（参数列表）&#123;</span><br><span class="line">可能会出现线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：同步方法会把方法内部的代码锁住，只让一个线程执行，同步方法的锁对象就是实现类对象。</p>
<p>静态的同步方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">格式</span><br><span class="line">修饰符 static synchronized 返回值类型 方法名（参数列表）&#123;</span><br><span class="line">可能会出现线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：锁对象是谁？不能是this，this是创建对象之后产生的，静态方法优先于对象，静态方法的锁对象是本类的class属性–&gt;class文件对象（反射)</p>
<h5 id="5-Lock锁"><a href="#5-Lock锁" class="headerlink" title="5.Lock锁"></a>5.Lock锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用步骤：</span><br><span class="line">1.在成员位置创建ReentrantLock对象</span><br><span class="line">2.在可能会出现安全问题的代码前调用Lock接口中的lock方法获取锁。</span><br><span class="line">3.在可能会出现安全问题的代码后调用Lock接口中的unlock方法释放锁。</span><br></pre></td></tr></table></figure>

<h4 id="6-线程状态"><a href="#6-线程状态" class="headerlink" title="6.线程状态"></a>6.线程状态</h4><h5 id="1-线程状态概述"><a href="#1-线程状态概述" class="headerlink" title="1.线程状态概述"></a>1.线程状态概述</h5><ul>
<li>NEW<br>至今尚未启动的线程处于这种状态。 </li>
<li>RUNNABLE<br>正在  Java 虚拟机中执行的线程处于这种状态。 </li>
<li>BLOCKED<br>受阻塞并等待某个监视器锁的线程处于这种状态。 </li>
<li>WAITING<br>无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。 </li>
<li>TIMED_WAITING<br>等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 </li>
<li>TERMINATED<br>已退出的线程处于这种状态。 </li>
</ul>
<p><img src="https://www.hualigs.cn/image/606435eeb0e7d.jpg" alt="线程状态图"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建锁对象保证唯一</span></span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">//创建顾客线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;顾客：告知老板要的包子数量&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        obj.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//唤醒之后执行的代码</span></span><br><span class="line">                System.out.println(<span class="string">&quot;顾客：开吃&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        <span class="comment">//创建老板线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                      System.out.println(<span class="string">&quot;老板：花了五秒做包子,做好之后，告知顾客可以吃了&quot;</span>);</span><br><span class="line">                      obj.notify();</span><br><span class="line">                  &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-调用wait和notify方法需要注意的细节"><a href="#7-调用wait和notify方法需要注意的细节" class="headerlink" title="7.调用wait和notify方法需要注意的细节"></a>7.调用wait和notify方法需要注意的细节</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.wait方法和notify方法必须由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用同一个锁对象调用的wait方法后的线程。</span><br><span class="line">2.wait方法和notify方法是属于Object类的方法。因为：锁对象可以是任意对象，而任意对象的所属类都是继承Object类</span><br><span class="line">3.wait方法和notify方法必须要在同步代码块或是同步函数中使用。因为：必须通过锁对象调用这两个方法。</span><br></pre></td></tr></table></figure>

<h4 id="8-线程池"><a href="#8-线程池" class="headerlink" title="8.线程池"></a>8.线程池</h4><p><img src="https://www.hualigs.cn/image/606470e53327f.jpg"></p>
<p>线程池：JDK1.5之后提供的</p>
<p>java.util.concurrent.Executors：线程池的工厂类，用来生成线程池。</p>
<p>static ExecutorService newFixedThreadPool(int nThreads)<br>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。 </p>
<p><strong>线程池的使用步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</span><br><span class="line">2.创建一个类，实现Runnable接口，重写run方法，设置线程任务</span><br><span class="line">3.调用ExecutorService中的方法submit，传递线程任务（实现类），开启线程，执行run方法</span><br><span class="line">4.调用ExecutorService中的方法shutdown销毁线程池（不建议执行）</span><br></pre></td></tr></table></figure>

<h3 id="八-Lambda表达式"><a href="#八-Lambda表达式" class="headerlink" title="八.Lambda表达式"></a>八.Lambda表达式</h3><h4 id="Lambda表达式的标准格式"><a href="#Lambda表达式的标准格式" class="headerlink" title="Lambda表达式的标准格式"></a>Lambda表达式的标准格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">由三部分组成：</span><br><span class="line">1.一些参数</span><br><span class="line">2.一个箭头</span><br><span class="line">3.一段代码</span><br><span class="line">格式：（参数列表）-&gt;&#123;重写方法的代码&#125;;</span><br><span class="line">解析：</span><br><span class="line">（）:接口中抽象方法的参数列表，没有参数，就空着，有参数就写出参数，多个参数使用逗号分隔，</span><br><span class="line">-&gt;:传递的意思，把参数传递给方法体&#123;&#125;</span><br><span class="line">&#123;&#125;:重写接口的抽象方法的方法体</span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式的省略格式"><a href="#Lambda表达式的省略格式" class="headerlink" title="Lambda表达式的省略格式"></a>Lambda表达式的省略格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">可以省略的内容：</span><br><span class="line">1.（参数列表）：括号中参数列表的数据类型，可以省略不写</span><br><span class="line">2.（参数列表）：括号中的参数如果只有一个，那么类型和（）都可以省略</span><br><span class="line">3.&#123;一些代码&#125;：如果&#123;&#125;中的代码只有一行，无论是否有返回值，都可以省略（&#123;&#125;，return，分号）</span><br><span class="line">注意：要省略&#123;&#125;，return，分号必须一起省略</span><br></pre></td></tr></table></figure>

<h4 id="Lambda表达式的使用前提"><a href="#Lambda表达式的使用前提" class="headerlink" title="Lambda表达式的使用前提"></a>Lambda表达式的使用前提</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.使用Lambda必须具有接口，且要求接口中有且仅有一个抽象方法。</span><br><span class="line">2.使用Lambda必须具有上下文推断（也就是方法的参数或局部变量类型必须为Lambda对应的接口类型，才能使用Lambda作为接口的实例）</span><br><span class="line">注意：有且仅有一个方法的接口，称为函数式接口。</span><br></pre></td></tr></table></figure>

<h3 id="九-File类"><a href="#九-File类" class="headerlink" title="九.File类"></a>九.File类</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java.io.File类</span><br><span class="line">文件和目录路径名的抽象表示形式。</span><br><span class="line">Java把电脑中的文件和文件夹（目录）封装为了一个File类，我们可以使用File类对文件和文件夹进行操作</span><br><span class="line">我们可以使用File类的方法：</span><br><span class="line">1.创建一个文件/文件夹</span><br><span class="line">2.删除一个文件/文件夹</span><br><span class="line">3.获取一个文件/文件夹</span><br><span class="line">4.判断文件夹是否存在</span><br><span class="line">5.对文件夹进行遍历</span><br><span class="line">6.获取文件的大小</span><br><span class="line">注意：File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法</span><br><span class="line">重点：记住三个单词</span><br><span class="line">file：文件</span><br><span class="line">directory：文件夹/目录</span><br><span class="line">path：路径</span><br></pre></td></tr></table></figure>

<h4 id="2-File类的静态成员变量"><a href="#2-File类的静态成员变量" class="headerlink" title="2.File类的静态成员变量"></a>2.File类的静态成员变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String pathSeparator <span class="comment">//与系统有关的路径分隔符，为了方便，它被表示为一个字符串。路径分割符：windows(;)linux(:)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> pathSeparatorChar <span class="comment">//与系统有关的路径分隔符。 文件名称分隔符：windows(反斜杠\)linux(/)</span></span><br><span class="line"><span class="keyword">static</span> String separator <span class="comment">//与系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。 windows(\)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> separatorChar <span class="comment">//与系统有关的默认名称分隔符。  windows(\)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-绝对路径和相对路径"><a href="#3-绝对路径和相对路径" class="headerlink" title="3.绝对路径和相对路径"></a>3.绝对路径和相对路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">绝对路径：是一个完整的路径（以盘符（C:/D:）开始的路径）</span><br><span class="line">相对路径：是一个简化的路径（相对路劲是相对于当前项目的根路径，路径可以简化书写）</span><br><span class="line">注意：</span><br><span class="line">1.路径是不区分大小写的</span><br><span class="line">2.路径中的文件名称分隔符，windows使用反斜杠（\），反斜杠是转义字符，两个反斜杠代表一个普通的反斜杠</span><br></pre></td></tr></table></figure>

<h4 id="4-File类的构造方法"><a href="#4-File类的构造方法" class="headerlink" title="4.File类的构造方法"></a>4.File类的构造方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">File(String pathname) </span><br><span class="line">          通过将给定路径名字符串转换为抽象路径名来创建一个新 File 实例。 </span><br><span class="line">注意：参数:String pathname是字符串的路径名称</span><br><span class="line">		 路径可以是以文件结尾，也可以是以文件夹结尾</span><br><span class="line">		 路径可以是相对路径也可以是绝对路径</span><br><span class="line">		 路径可以是存在的，也可以是不存在的</span><br><span class="line">		 创建File对象，只是把字符串封装为File对象，不考虑路径的真假情况</span><br><span class="line">File(File parent, String child) </span><br><span class="line">          根据 parent 抽象路径名和 child 路径名字符串创建一个新 File 实例。 </span><br><span class="line">File(String parent, String child) </span><br><span class="line">          根据 parent 路径名字符串和 child 路径名字符串创建一个新 File 实例。 </span><br><span class="line">File(URI uri) </span><br><span class="line">          通过将给定的 file: URI 转换为一个抽象路径名来创建一个新的 File 实例。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-File类获取功能的方法"><a href="#5-File类获取功能的方法" class="headerlink" title="5.File类获取功能的方法"></a>5.File类获取功能的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无论构造方法中传递的是相对路径还是绝对路径，getAbsolutePath方法返回的都是绝对路径</span></span><br><span class="line">  <span class="function">String <span class="title">getAbsolutePath</span><span class="params">()</span>  <span class="comment">//抽象路径名的绝对路径名字符串。</span></span></span><br><span class="line"><span class="function"><span class="comment">//构造方法中传递的是什么，getPath方法返回的就是什么</span></span></span><br><span class="line"><span class="function">  String <span class="title">getPath</span><span class="params">()</span> <span class="comment">//抽象路径名转换为一个路径名字符串。 </span></span></span><br><span class="line"><span class="function"><span class="comment">//获取的就是构造方法中传递的路径的结尾部分（文件/文件夹）</span></span></span><br><span class="line"><span class="function">  String <span class="title">getName</span><span class="params">()</span> <span class="comment">//由此抽象路径名表示的文件或目录的名称。 </span></span></span><br><span class="line"><span class="function"><span class="comment">//获取文件的大小，以字节为单位，文件夹是没有大小概念的，不能获取文件夹的大小（返回的是0），如果路径不存在，则返回0</span></span></span><br><span class="line"><span class="function">  <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//由此抽象路径名表示的文件的长度。 </span></span></span><br></pre></td></tr></table></figure>

<h4 id="6-File类判断功能的方法"><a href="#6-File类判断功能的方法" class="headerlink" title="6.File类判断功能的方法"></a>6.File类判断功能的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> <span class="comment">//测试此抽象路径名表示的文件或目录是否存在。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> <span class="comment">//测试此抽象路径名表示的文件是否是一个目录。 </span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> <span class="comment">//测试此抽象路径名表示的文件是否是一个标准文件。 </span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h4 id="7-File类创建删除功能的方法"><a href="#7-File类创建删除功能的方法" class="headerlink" title="7.File类创建删除功能的方法"></a>7.File类创建删除功能的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此方法只能创建文件，不能创建文件夹，创建文件的路径必须存在，否则会抛出异常，如果文件存在，返回false</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> <span class="comment">//当且仅当不存在具有此抽象路径名指定名称的文件时，不可分地创建一个新的空文件。</span></span></span><br><span class="line"><span class="function"><span class="comment">//----------------------------------------------------------------------------------------</span></span></span><br><span class="line"><span class="function"><span class="comment">//只能创建单级文件夹</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> <span class="comment">//创建此抽象路径名指定的目录。 </span></span></span><br><span class="line"><span class="function"><span class="comment">//既可以创建单级，也可以创建多级</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> <span class="comment">//创建此抽象路径名指定的目录，包括所有必需但不存在的父目录。 </span></span></span><br><span class="line"><span class="function"><span class="comment">//返回值 true：文件不存在，创建文件，返回true   false：文件存在，不会创建，返回false</span></span></span><br><span class="line"><span class="function"><span class="comment">//注意：只能创建文件夹，不能创建文件，创建文件的路径必须存在，否则会抛出异常，如果文件存在，返回false</span></span></span><br><span class="line"><span class="function"><span class="comment">//-----------------------------------------------------------------------------</span></span></span><br><span class="line"><span class="function"><span class="comment">//文件/文件夹删除成功，返回true，文件夹中有内容，不会删除返回false，构造方法中路径不存在返回false</span></span></span><br><span class="line"><span class="function"><span class="comment">//删除成功后不会到回收站</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> <span class="comment">//删除此抽象路径名表示的文件或目录。 </span></span></span><br></pre></td></tr></table></figure>

<h4 id="8-File类遍历目录功能"><a href="#8-File类遍历目录功能" class="headerlink" title="8.File类遍历目录功能"></a>8.File类遍历目录功能</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回File类型的数组，</span></span><br><span class="line">File[] listFiles() <span class="comment">//返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。 </span></span><br><span class="line"><span class="comment">//返回String类型的数组，数组中存储的是文件或文件夹的名称</span></span><br><span class="line">String[] list() <span class="comment">//返回一个字符串数组，这些字符串指定此抽象路径名表示的目录中的文件和目录。 </span></span><br><span class="line"><span class="comment">//注意：1. tFiles和list方法遍历的是构造方法中给出的目录。</span></span><br><span class="line"><span class="comment">//2.如果构造方法中给出的路径的目录不存在，会抛出空指针异常。</span></span><br><span class="line"><span class="comment">//3.如果构造方法中给出的路径不是一个目录，会抛出空指针异常。</span></span><br><span class="line"><span class="comment">//4.可以获取隐藏的文件或文件夹的名称</span></span><br></pre></td></tr></table></figure>

<h4 id="9-递归打印多级目录-amp-搜索文件"><a href="#9-递归打印多级目录-amp-搜索文件" class="headerlink" title="9.递归打印多级目录&amp;搜索文件"></a>9.递归打印多级目录&amp;搜索文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiGuiWenJianJia</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\aaaaa&quot;</span>);</span><br><span class="line">        getAllFiles(file);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------&quot;</span>);</span><br><span class="line">        getAppointFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取指定的文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAppointFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file1 : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file1.isDirectory()) &#123;</span><br><span class="line">                <span class="comment">//System.out.println(file1.getName());</span></span><br><span class="line">                getAllFiles(file1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//String path = file1.getPath();</span></span><br><span class="line">                <span class="comment">//String s = file1.toString();</span></span><br><span class="line">                String name = file1.getName();</span><br><span class="line">                <span class="keyword">boolean</span> b = name.endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                    System.out.println(file1.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取要遍历的目录虾下面的所有文件和目录的名称</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File file1 : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file1.isDirectory()) &#123;</span><br><span class="line">                System.out.println(file1.getName());</span><br><span class="line">                getAllFiles(file1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(file1.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-FileFilter过滤器"><a href="#10-FileFilter过滤器" class="headerlink" title="10.FileFilter过滤器"></a>10.FileFilter过滤器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**FileFilter是用于抽象路径名的过滤器。是一个接口，有一个抽象方法accept。</span></span><br><span class="line"><span class="comment">*boolean accept(File pathname)测试指定抽象路径名是否应该包含在某个路径名列表中。 </span></span><br><span class="line"><span class="comment">*参数：File pathname：使用fileLists遍历目录，获取每个文件对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">File[] listFiles(FileFilter filter)<span class="comment">//返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*FilenameFilter 实现此接口的类实例可用于过滤器文件名。</span></span><br><span class="line"><span class="comment">*作用：用于过滤文件名称</span></span><br><span class="line"><span class="comment">*抽象方法：boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。</span></span><br><span class="line"><span class="comment">*参数：File dir：构造方法中传递的被遍历的目录， String name：使用fileLists遍历目录，获取每个文件/文件夹的名称</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">File[] listFiles(FilenameFilter filter)<span class="comment">//返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。 </span></span><br></pre></td></tr></table></figure>

<h5 id="1-使用FileFilter-FilenameFilter获取指定文件"><a href="#1-使用FileFilter-FilenameFilter获取指定文件" class="headerlink" title="1.使用FileFilter|FilenameFilter获取指定文件"></a>1.使用FileFilter|FilenameFilter获取指定文件</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用过滤器获取指定文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileFilterTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\aaaaa&quot;</span>);</span><br><span class="line">        getAppointFiles(file);</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------------------&quot;</span>);</span><br><span class="line">        getAppointFiles01(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAppointFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * FilenameFilter实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        File[] files = dir.listFiles(<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (pathname.isDirectory()) &#123;</span><br><span class="line">                    getAppointFiles(pathname);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> pathname.getName().toLowerCase().endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getAppointFiles01</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * FilenameFilter实现</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        File[] files1 = dir.listFiles(<span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> File(dir,name).isDirectory())&#123;</span><br><span class="line">                    getAppointFiles(<span class="keyword">new</span> File(dir,name));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> name.toLowerCase().endsWith(<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (File file1 : files1) &#123;</span><br><span class="line">            System.out.println(file1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十-IO流"><a href="#十-IO流" class="headerlink" title="十.IO流"></a>十.IO流</h3><h4 id="1-IO概述"><a href="#1-IO概述" class="headerlink" title="1.IO概述"></a>1.IO概述</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i：input</span><br><span class="line">o：output</span><br><span class="line">流：数据（字符，字节）一个字符=2个字节 一个字节 = 8个二进制位</span><br><span class="line">字节流的顶级父类：InputStream，OutputStream</span><br><span class="line">字符流的顶级父类：Reader，Writer</span><br></pre></td></tr></table></figure>

<h4 id="2-字节输出流"><a href="#2-字节输出流" class="headerlink" title="2.字节输出流"></a>2.字节输出流</h4><h5 id="1-FileOutputStream"><a href="#1-FileOutputStream" class="headerlink" title="1.FileOutputStream"></a>1.FileOutputStream</h5><p><strong>构造方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name)<span class="comment">//创建一个向具有指定名称的文件中写入数据的输出文件流。</span></span><br><span class="line">FileOutputStream(File file) <span class="comment">//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</span></span><br><span class="line">参数：写入数据的目的地</span><br><span class="line">     String name 目的地是一个文件的路径</span><br><span class="line">     File file 目的地是一个文件</span><br><span class="line">作用：<span class="number">1.</span>创建一个FileOutputStream对象</span><br><span class="line">    <span class="number">2.</span>会根据构造方法中传递的文件/文件路径，创建一个空的文件</span><br><span class="line">    <span class="number">3.</span>会把FileOutputStream对象指向创建好的文件</span><br></pre></td></tr></table></figure>

<p><strong>字节输出流的使用步骤：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建一个FileOutputStream对象，构造方法中传递写入数据的目的地</span><br><span class="line"><span class="number">2.</span>调用FileOutputStream对象中的方法write，把数据写入文件中</span><br><span class="line"><span class="number">3.</span>释放资源（流使用会占用一定的内存，使用完毕要把内存清空，提高程序的效率）</span><br></pre></td></tr></table></figure>

<p><strong>write方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次写多个字节，如果写的第一个字节是正数（0-127），那么显示的时候会查询ASCII表，如果写的第一个字节是负数，那么第一个字节会和第二个字节，两个字节一起组成一个中文显示，查询系统默认码表（GBK）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//将 b.length 个字节从指定 byte 数组写入此文件输出流中。 </span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。 </span></span></span><br><span class="line"><span class="function"> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="comment">//将指定字节写入此文件输出流。 </span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>字节输出流的追加写和换行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream(String name, <span class="keyword">boolean</span> append) <span class="comment">//创建一个向具有指定 name 的文件中写入数据的输出文件流。</span></span><br><span class="line">FileOutputStream(File file, <span class="keyword">boolean</span> append) <span class="comment">//创建一个向指定 File 对象表示的文件中写入数据的文件输出流。</span></span><br><span class="line">参数：String name，File file 写入数据的目的地</span><br><span class="line">    <span class="keyword">boolean</span> append：追加写开关</span><br><span class="line">    <span class="keyword">true</span>：创建对象不会覆盖源文件，继续在文件的末尾追加写数据</span><br><span class="line">    <span class="keyword">false</span>：创建一个新文件，覆盖原文件</span><br><span class="line">写换行：换行符号</span><br><span class="line">    windows：\r\n</span><br><span class="line">    linux:/n</span><br><span class="line">    mac:/r</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src\\a.txt&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        fileOutputStream.write(<span class="string">&quot;你好&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            fileOutputStream.write(<span class="string">&quot;你好&quot;</span>.getBytes());</span><br><span class="line">            fileOutputStream.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-字节输入流"><a href="#3-字节输入流" class="headerlink" title="3.字节输入流"></a>3.字节输入流</h4><h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><p><strong>作用：</strong>把硬盘中的数据读取到内存中使用</p>
<p><strong>注意：</strong>一个中文：GBK（2个字节），UTF-8（3个字节）</p>
<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream(File file) <span class="comment">//通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的 File 对象 file 指定。</span></span><br><span class="line">FileInputStream(String name)<span class="comment">//通过打开一个到实际文件的连接来创建一个 FileInputStream，该文件通过文件系统中的路径名 name 指定。</span></span><br><span class="line">参数：String name 文件的路径</span><br><span class="line">     File file 文件</span><br><span class="line">作用：<span class="number">1.</span>会创建FileInputStream对象</span><br><span class="line">     <span class="number">2.</span>会把FileInputStream对象指定构造方法中要读取的文件</span><br></pre></td></tr></table></figure>

<p><strong>字节输入流的使用步骤：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个FileInputStream对象，构造方法中绑定要读取的数据源</span><br><span class="line">2.调用FileInputStream对象中的方法read，读取文件</span><br><span class="line">3.释放资源</span><br></pre></td></tr></table></figure>

<p><strong>read方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取一个字节，读到文件的末尾返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span><span class="comment">//从此输入流中读取一个数据字节。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="comment">//从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中。 </span></span></span><br><span class="line"><span class="function"><span class="comment">/*参数 byte[] b的作用：起到缓冲作用，存储每次读取到的多个字节</span></span></span><br><span class="line"><span class="comment"><span class="function">       数组的长度一般定义为1024或者1024的整数倍</span></span></span><br><span class="line"><span class="comment"><span class="function">  方法的返回值int是什么？每次读取的有效字节个数</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//固定写法</span></span><br><span class="line">        <span class="keyword">while</span>((len = fileInputStream.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src\\a.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fileInputStream.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>文件复制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件复制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileCopy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;d:\\1.jpg&quot;</span>);</span><br><span class="line">        FileOutputStream fos  =<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\aaaaa\\2.jpg&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h4><h5 id="1-Reader"><a href="#1-Reader" class="headerlink" title="1.Reader"></a>1.Reader</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader：是抽象类，是字符输入流的超类</span><br></pre></td></tr></table></figure>

<p><strong>共性的成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="comment">//读取单个字符。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> <span class="comment">//将字符读入数组。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="comment">//关闭该流并释放与之关联的所有资源。 </span></span></span><br></pre></td></tr></table></figure>

<h5 id="2-FileReader-文件字符输入流"><a href="#2-FileReader-文件字符输入流" class="headerlink" title="2.FileReader(文件字符输入流)"></a>2.FileReader(文件字符输入流)</h5><p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FileReader(String fileName)  在给定从中读取数据的文件名的情况下创建一个新 FileReader。</span><br><span class="line">FileReader(File file)<span class="comment">//在给定从中读取数据的 File 的情况下创建一个新 FileReader。</span></span><br><span class="line"><span class="comment">//参数：读取的数据源 String fileName：文件的路径 File file 一个文件</span></span><br><span class="line"><span class="comment">//作用：1.会创建一个FileReader对象 2.会把FileReader对象指向要读取的文件</span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个FileReader对象，构造方法中绑定要读取的数据源</span><br><span class="line">2.调用FileInputStream对象中的方法read，读取文件</span><br><span class="line">3.释放资源</span><br></pre></td></tr></table></figure>

<h5 id="3-Writer"><a href="#3-Writer" class="headerlink" title="3.Writer"></a>3.Writer</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer:是抽象类，是字符输出流的超类</span><br></pre></td></tr></table></figure>

<p><strong>共性的成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="comment">//关闭此流，但要先刷新它。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="comment">//刷新该流的缓冲。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> <span class="comment">//写入字符数组。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//写入字符数组的某一部分。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> <span class="comment">//写入单个字符。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> <span class="comment">//写入字符串。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//写入字符串的某一部分。 </span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h5 id="4-FileWriter（文件字符输出流）"><a href="#4-FileWriter（文件字符输出流）" class="headerlink" title="4.FileWriter（文件字符输出流）"></a>4.FileWriter（文件字符输出流）</h5><p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(File file) <span class="comment">//根据给定的 File 对象构造一个 FileWriter 对象。</span></span><br><span class="line">FileWriter(String fileName) <span class="comment">//根据给定的文件名构造一个 FileWriter 对象。</span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建一个FileWriter对象，构造方法中绑定要写入数据的目的地</span><br><span class="line">2.调用FileWriter对象中的方法write，把数据写入内存缓冲区（字符转换为字节的过程）</span><br><span class="line">3.使用FileWriter中的方法flush，把内存缓冲区的数据，刷新到文件中</span><br><span class="line">4.释放资源（会先把内存缓冲区的数据刷新到文件中）</span><br></pre></td></tr></table></figure>

<p><strong>flush和close方法的区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush:刷新缓冲区，流对象可以继续使用</span><br><span class="line">close：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了</span><br></pre></td></tr></table></figure>

<p><strong>字符流的续写和换行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FileWriter(File file, <span class="keyword">boolean</span> append) <span class="comment">//根据给定的 File 对象构造一个 FileWriter 对象。</span></span><br><span class="line">FileWriter(String fileName, <span class="keyword">boolean</span> append) <span class="comment">//根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。</span></span><br><span class="line">参数：String name，File file 写入数据的目的地</span><br><span class="line">    <span class="keyword">boolean</span> append：追加写开关</span><br><span class="line">    <span class="keyword">true</span>：创建对象不会覆盖源文件，继续在文件的末尾追加写数据</span><br><span class="line">    <span class="keyword">false</span>：创建一个新文件，覆盖原文件</span><br><span class="line">写换行：换行符号</span><br><span class="line">    windows：\r\n</span><br><span class="line">    linux:/n</span><br><span class="line">    mac:/r</span><br></pre></td></tr></table></figure>

<h4 id="5-Properties集合"><a href="#5-Properties集合" class="headerlink" title="5.Properties集合"></a>5.Properties集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Properties集合是一个唯一和IO流相结合的集合，属性列表中每个键值对都是一个字符串，Properties集合是双列集合，key和value默认是字符串。</span><br><span class="line">可以使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储。</span><br><span class="line">可以使用Properties集合中的方法load，把硬盘中保存的文件（键值对），读取到集合中使用。</span><br><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key, String value)</span> <span class="comment">//调用 Hashtable 的方法 put。 </span></span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span><span class="comment">//用指定的键在此属性列表中搜索属性。 </span></span></span><br><span class="line"><span class="function">Set&lt;String&gt; <span class="title">stringPropertyNames</span><span class="params">()</span> <span class="comment">//返回此属性列表中的键集，其中该键及其对应值是字符串，如果在主属性列表中未找到同名的键，则还包括默认属性列表中不同的键。 </span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建Properties对象，添加数据</span><br><span class="line">2.创建字节/字符输出流，对象，构造方法中绑定要输出的目的地</span><br><span class="line">3.使用Properties集合中的方法store，把集合中的临时数据，持久化写入到硬盘中存储</span><br><span class="line">4.释放资源</span><br></pre></td></tr></table></figure>

<p><strong>Properties集合中的store方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;2001&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;2002&quot;</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        properties.setProperty(<span class="string">&quot;2003&quot;</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">        FileWriter fileWriter = <span class="keyword">new</span> FileWriter(<span class="string">&quot;src/com/company/propertiesdemo/a.txt&quot;</span>);</span><br><span class="line">        properties.store(fileWriter,<span class="string">&quot;save file&quot;</span>);</span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Properties集合中的load方法</strong></p>
<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建Properties对象</span><br><span class="line">2.使用Properties集合对象中的方法load读取保存键值对的文件</span><br><span class="line">3.遍历Properties集合</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.存储键值对的文件中，键与值的默认的连接符号可以使用=，空格（其他符号）</span><br><span class="line">2.存储键值对的文件中，可以使用#进行注释，被注释的键值对不会再被读取</span><br><span class="line">3.存储键值对的文件中，键与值默认都是字符串，不用再加上引号</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.load(<span class="keyword">new</span> FileReader(<span class="string">&quot;src/com/company/propertiesdemo/a.txt&quot;</span>));</span><br><span class="line">        Set&lt;String&gt; set = properties.stringPropertyNames();</span><br><span class="line">        <span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">            String value = properties.getProperty(key);</span><br><span class="line">            System.out.println(<span class="string">&quot;key:&quot;</span>+key+<span class="string">&quot;value:&quot;</span>+value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-缓冲流"><a href="#6-缓冲流" class="headerlink" title="6.缓冲流"></a>6.缓冲流</h4><h5 id="1-BufferedOutputStream-字节缓冲输出流"><a href="#1-BufferedOutputStream-字节缓冲输出流" class="headerlink" title="1.BufferedOutputStream(字节缓冲输出流)"></a>1.BufferedOutputStream(字节缓冲输出流)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStreamextends</span> <span class="title">FilterOutputStream</span></span></span><br><span class="line"><span class="class">//该类实现缓冲的输出流。通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。 </span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedOutputStream(OutputStream out) <span class="comment">//创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 </span></span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="keyword">int</span> size) <span class="comment">//创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数：OutputStream out：字节输出流 我们可以传递FileOutputStream，缓冲流会给FileOutputStream增加一个缓冲区，提高File 	*	  OutputStream对象效率，int size：指定缓冲流内部缓冲区的大小，把数据写入内部缓冲区中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.创建FileOutputStream，构造方法中绑定要输出的目的地。</span><br><span class="line">2.创建BufferedOutputStream，构造方法中传递FileOutputStream对象，提高FileOutputStream对象效率</span><br><span class="line">3.使用BufferedOutputStream对象中的write方法，把数据写入内部缓冲区中</span><br><span class="line">4.使用BufferedOutputStream对象中的方法flush，把内部缓冲区中的数据，刷新到文件中</span><br><span class="line">5.释放资源（会先调用flush方法刷新数据，第四步可以省略）</span><br></pre></td></tr></table></figure>

<h5 id="2-BufferedInputStream-字节缓冲输入流"><a href="#2-BufferedInputStream-字节缓冲输入流" class="headerlink" title="2.BufferedInputStream(字节缓冲输入流)"></a>2.BufferedInputStream(字节缓冲输入流)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStreamextends</span> <span class="title">FilterInputStream</span></span></span><br><span class="line"><span class="class">//<span class="title">BufferedInputStream</span> 为另一个输入流添加一些功能，即缓冲输入以及支持 <span class="title">mark</span> 和 <span class="title">reset</span> 方法的能力。在创建 <span class="title">BufferedInputStream</span> 时，会创建一个内部缓冲区数组。在读取或跳过流中的字节时，可根据需要从包含的输入流再次填充该内部缓冲区，一次填充多个字节。<span class="title">mark</span> 操作记录输入流中的某个点，<span class="title">reset</span> 操作使得在从包含的输入流中获取新字节之前，再次读取自最后一次 <span class="title">mark</span> 操作后读取的所有字节。</span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedInputStream(InputStream in) <span class="comment">//创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 </span></span><br><span class="line">BufferedInputStream(InputStream in, <span class="keyword">int</span> size) <span class="comment">//创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数：InputStream in：字节输入流</span></span><br><span class="line"><span class="comment">	我们可以传递FileInputStream，缓冲流会给FileInputStream增加一个缓冲区，提高FileInputStream对象效率</span></span><br><span class="line"><span class="comment">	int size：指定缓冲流内部缓冲区的大小，不指定默认</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建FileInputStream，构造方法中绑定要读取的数据源。</span><br><span class="line">2.创建BufferedInputStream对象，构造方法中传递FileInputStream对象，提高FileInputStream对象效率</span><br><span class="line">3.使用BufferedInputStream对象中的read方法，读取文件</span><br><span class="line">4.释放资源（）</span><br></pre></td></tr></table></figure>

<h5 id="3-BufferedWriter-字符缓冲输出流"><a href="#3-BufferedWriter-字符缓冲输出流" class="headerlink" title="3.BufferedWriter(字符缓冲输出流)"></a>3.BufferedWriter(字符缓冲输出流)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span></span></span><br><span class="line"><span class="class">//将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。 </span></span><br><span class="line"><span class="class">//可以指定缓冲区的大小，或者接受默认的大小。在大多数情况下，默认值就足够大了。 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//该类提供了 <span class="title">newLine</span>() 方法，它使用平台自己的行分隔符概念，此概念由系统属性 <span class="title">line</span>.<span class="title">separator</span> 定义。并非所有平台都使用新行符 (&#x27;\<span class="title">n</span>&#x27;) 来终止各行。因此调用此方法来终止每个输出行要优于直接写入新行符。 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedWriter(Writer out) <span class="comment">//创建一个使用默认大小输出缓冲区的缓冲字符输出流。 </span></span><br><span class="line">BufferedWriter(Writer out, <span class="keyword">int</span> sz) <span class="comment">//创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数：Writer out：字符输出流</span></span><br><span class="line"><span class="comment">	我们可以传递FileWriter，缓冲流会给FileWriter增加一个缓冲区，提高FileWriter对象效率</span></span><br><span class="line"><span class="comment">	int size：指定缓冲流内部缓冲区的大小，不指定默认</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>特有的成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> <span class="comment">//写入一个行分隔符。 会根据不同的系统，获取不同的分隔符</span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建字符缓冲输出流对象，构造方法中传递字符输出流</span><br><span class="line">2.调用字符缓冲输出流中的方法write，把数据写入到内存缓冲区中</span><br><span class="line">3. 调用字符缓冲输出流中的方法flush，把内部缓冲区中的数据，刷新到文件中</span><br><span class="line">4.释放资源</span><br></pre></td></tr></table></figure>

<h5 id="4-BufferedReader"><a href="#4-BufferedReader" class="headerlink" title="4.BufferedReader"></a>4.BufferedReader</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReader</span> <span class="keyword">extends</span> <span class="title">Reader</span></span></span><br><span class="line"><span class="class">//从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//可以指定缓冲区的大小，或者可使用默认的大小。大多数情况下，默认值就足够大了。 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//通常，<span class="title">Reader</span> 所作的每个读取请求都会导致对底层字符或字节流进行相应的读取请求。因此，建议用 <span class="title">BufferedReader</span> 包装所有其 <span class="title">read</span>() 操作可能开销很高的 <span class="title">Reader</span>（如 <span class="title">FileReader</span> 和 <span class="title">InputStreamReader</span>）。</span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader(Reader in) <span class="comment">//创建一个使用默认大小输入缓冲区的缓冲字符输入流。 </span></span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> sz) <span class="comment">//创建一个使用指定大小输入缓冲区的缓冲字符输入流。 </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数：Reader in：字符输入流</span></span><br><span class="line"><span class="comment">	我们可以传递FileReader，缓冲流会给FileReader增加一个缓冲区，提高FileReader对象效率</span></span><br><span class="line"><span class="comment">	int size：指定缓冲流内部缓冲区的大小，不指定默认</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>特有的成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">readLine</span><span class="params">()</span> <span class="comment">// 读取一个文本行。 </span></span></span><br><span class="line"><span class="function"><span class="comment">//读取一个文本行。通过下列字符之一即可认为某行已终止：换行 (&#x27;\n&#x27;)、回车 (&#x27;\r&#x27;) 或回车后直接跟着换行。 </span></span></span><br><span class="line"><span class="function"><span class="comment">//返回：包含该行内容的字符串，不包含任何行终止符，如果已到达流末尾，则返回 null </span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建字符缓冲输入流对象，构造方法中传递字符输入流</span><br><span class="line">2.调用字符缓冲输出流中的方法read/readline读取文本</span><br><span class="line">3.释放资源</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;src/a.txt&quot;</span>));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-转换流"><a href="#7-转换流" class="headerlink" title="7.转换流"></a>7.转换流</h4><h5 id="1-OutputStreamWriter"><a href="#1-OutputStreamWriter" class="headerlink" title="1.OutputStreamWriter"></a>1.OutputStreamWriter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span></span></span><br><span class="line"><span class="class">//<span class="title">OutputStreamWriter</span> 是字符流通向字节流的桥梁：可使用指定的 <span class="title">charset</span> 将要写入流中的字符编码成字节。它使用的字符集可以由名称指定或显式给定，否则将接受平台默认的字符集。 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//每次调用 <span class="title">write</span>() 方法都会导致在给定字符（或字符集）上调用编码转换器。在写入底层输出流之前，得到的这些字节将在缓冲区中累积。可以指定此缓冲区的大小，不过，默认的缓冲区对多数用途来说已足够大。注意，传递给 <span class="title">write</span>() 方法的字符没有缓冲。 </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStreamWriter(OutputStream out) <span class="comment">//创建使用默认字符编码的 OutputStreamWriter。</span></span><br><span class="line">OutputStreamWriter(OutputStream out, String charsetName) <span class="comment">//创建使用指定字符集的 OutputStreamWriter。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数：OutputStream out：字节输出流，可以用来写转换之后的字节到文件中</span></span><br><span class="line"><span class="comment">*	  String charsetName：指定的编码表名称，不区分大小写，可以是utf-8/UTF-8，gbk/GBK..,不指定默认utf-8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建OutputStreamWriter对象，构造方法中传递字节输出流和指定的编码表名称</span><br><span class="line">2.使用OutputStreamWriter对象中的方法write，把字符转换为字节存储到缓冲区中（编码）</span><br><span class="line">3.使用OutputStreamWriter对象中的方法flush，把内存缓冲区中的字节刷新到文件中（使用字节流写字节的过程）</span><br><span class="line">4.释放资源</span><br></pre></td></tr></table></figure>

<h5 id="2-InputStreamReader"><a href="#2-InputStreamReader" class="headerlink" title="2.InputStreamReader"></a>2.InputStreamReader</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReader</span> <span class="keyword">extends</span> <span class="title">Reader</span></span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader(InputStream in) //创建一个使用默认字符集的 InputStreamReader。</span><br><span class="line">InputStreamReader(InputStream in, String charsetName) //创建使用指定字符集的 InputStreamReader。</span><br><span class="line">/**</span><br><span class="line">*参数：InputStream in：字节输入流，用来读取文件中保存的字节</span><br><span class="line">*	  String charsetName：指定的编码表名称，不区分大小写，可以是utf-8/UTF-8，gbk/GBK..,不指定默认utf-8</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建InputStreamReader对象，构造方法中传递字节输出流和指定的编码表名称</span><br><span class="line">2.使用InputStreamReader对象中的方法read读取文件</span><br><span class="line">3.释放资源</span><br></pre></td></tr></table></figure>

<h4 id="8-序列化和反序列化"><a href="#8-序列化和反序列化" class="headerlink" title="8.序列化和反序列化"></a>8.序列化和反序列化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">序列化：序列化就是指把对象转换为字节序列的过程</span><br><span class="line">反序列化：把字节序列恢复为对象的过程。</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">序列化和反序列化的时候，会抛出NotSerializableException（没有序列化异常）</span><br><span class="line">类通过实现 java.io.Serializable 接口以启用其序列化功能。</span><br><span class="line">Serializable接口也叫标记型接口</span><br><span class="line">	要进行序列化和反序列化的时候，就会检测类上是否有这个标记</span><br><span class="line">	有：就会序列化和反序列化</span><br><span class="line">	没有：就会抛出NotSerializableException</span><br></pre></td></tr></table></figure>



<h5 id="1-ObjectOutputStream"><a href="#1-ObjectOutputStream" class="headerlink" title="1.ObjectOutputStream"></a>1.ObjectOutputStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStream</span> <span class="keyword">extends</span> <span class="title">OutputStream</span> <span class="keyword">implements</span> <span class="title">ObjectOutput</span>, <span class="title">ObjectStreamConstants</span></span></span><br><span class="line"><span class="class">//<span class="title">ObjectOutputStream</span> 将 <span class="title">Java</span> 对象的基本数据类型和图形写入 <span class="title">OutputStream</span>。可以使用 <span class="title">ObjectInputStream</span> 读取（重构）对象。通过在流中使用文件可以实现对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中重构对象。 </span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream(OutputStream out) <span class="comment">//创建写入指定 OutputStream 的 ObjectOutputStream。</span></span><br></pre></td></tr></table></figure>

<p><strong>特有的成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(Object obj)</span> <span class="comment">//将指定的对象写入 ObjectOutputStream。 </span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.创建ObjectOutputStream对象，构造方法中传递字节输出流</span><br><span class="line">2.使用ObjectOutputStream对象中的writeObject方法，把对象写到文件中</span><br><span class="line">3.释放资源</span><br></pre></td></tr></table></figure>

<h5 id="2-ObjectInputStream"><a href="#2-ObjectInputStream" class="headerlink" title="2.ObjectInputStream"></a>2.ObjectInputStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span>, <span class="title">ObjectStreamConstants</span> //<span class="title">ObjectInputStream</span> 对以前使用 <span class="title">ObjectOutputStream</span> 写入的基本数据和对象进行反序列化。 </span></span><br><span class="line"><span class="class"></span></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream(InputStream in) <span class="comment">//创建从指定 InputStream 读取的 ObjectInputStream。</span></span><br><span class="line"><span class="comment">//参数：InputStream in：字节输入流</span></span><br></pre></td></tr></table></figure>

<p><strong>特有的成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">readObject</span><span class="params">()</span> <span class="comment">//从 ObjectInputStream 读取对象。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException,ClassNotFoundException</span></span><br><span class="line"><span class="function"><span class="comment">//声明抛出了IOException,ClassNotFoundException</span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.创建ObjectInputStream对象，构造方法中传递字节输入流</span><br><span class="line">2.使用ObjectInputStream对象中的方法readObject，读取保存对象的文件</span><br><span class="line">3.释放资源</span><br><span class="line">4.使用读取出来的对象（打印）</span><br></pre></td></tr></table></figure>

<p><strong>反序列化的前提</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.类必须实现Serializable</span><br><span class="line">2必须存在类对应的class文件</span><br></pre></td></tr></table></figure>

<h5 id="3-transient关键字"><a href="#3-transient关键字" class="headerlink" title="3.transient关键字"></a>3.transient关键字</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被transient关键字修饰的成员变量，不能被序列化</span><br></pre></td></tr></table></figure>

<h4 id="9-PrintStream（打印流）"><a href="#9-PrintStream（打印流）" class="headerlink" title="9.PrintStream（打印流）"></a>9.PrintStream（打印流）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class PrintStream extends FilterOutputStream implements Appendable, CloseablePrintStream </span><br><span class="line">//为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.只负责数据的输出，不负责数据的读取</span><br><span class="line">2.与其他输出流不同，	PrintStream永远不会抛出IOException</span><br></pre></td></tr></table></figure>

<p><strong>特有的方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void print（任意类型的值） </span><br><span class="line">void println（任意类型的值并换行）</span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PrintStream(File file) <span class="comment">//创建具有指定文件且不带自动行刷新的新打印流。</span></span><br><span class="line">PrintStream(OutputStream out) <span class="comment">//创建新的打印流。 </span></span><br><span class="line">PrintStream(String fileName) <span class="comment">//创建具有指定文件名称且不带自动行刷新的新打印流。</span></span><br></pre></td></tr></table></figure>

<p><strong>继承自父类的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="comment">//将 len 字节从指定的初始偏移量为 off 的 byte 数组写入此流。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="comment">//将指定的字节写入此流。 </span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.如果使用继承自父类的write方法写数据，那么查看数据的时候会查询编码表 97-&gt;a</span><br><span class="line">2.如果使用自己特有的方法print/println方法写数据，写的数据原样输出 97-&gt;97</span><br></pre></td></tr></table></figure>

<h3 id="十一-网络编程"><a href="#十一-网络编程" class="headerlink" title="十一.网络编程"></a>十一.网络编程</h3><h4 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="1.软件结构"></a>1.软件结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C/S: C是英文单词“Client”的首字母，即客户端的意思，C/S就是“Client/Server”的缩写，即“客户端/服务器”模式。</span><br><span class="line">B/S: B是英文单词“Browser”的首字母，即浏览器的意思；S是英文单词“Server”的首字母，即服务器的意思。B/S就是“Browser/Server”的缩写，即“浏览器/服务器”模式。</span><br></pre></td></tr></table></figure>

<h4 id="2-网络通信协议"><a href="#2-网络通信协议" class="headerlink" title="2.网络通信协议"></a>2.网络通信协议</h4><p><strong>概念</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">网络通信协议是一种网络通用语言，为连接不同操作系统和不同硬件体系结构的互联网络引提供通信支持，是一种网络通用语言。</span><br><span class="line">网络通信协议由三个要素组成：</span><br><span class="line">语义，解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</span><br><span class="line">语法，用户数据与控制信息的结构与格式，以及数据出现的顺序。</span><br><span class="line">时序，对事件发生顺序的详细说明。</span><br><span class="line">可以形象地把这三个要素描述为：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</span><br></pre></td></tr></table></figure>

<h5 id="1-TCP-IP协议"><a href="#1-TCP-IP协议" class="headerlink" title="1.TCP/IP协议"></a>1.TCP/IP协议</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  TCP/IP（Transmission Control Protocol/Internet Protocol,传输控制协议/网际协议） 协议具有很强的灵活性，支持任意规模的网络，几乎可连接所有服务器和工作站。在使用TCP/IP协议时需要进行复杂的设置，每个结点至少需要一个“IP地址”、一个“子网掩码”、一个“默认网关”、一个“主机名”，对于一些初学者来说使用不太方便。</span><br><span class="line">  TCP/IP参考模型是首先由ARPANET所使用的网络体系结构，共分为四层：网络接口层（又称链路层）、网络层（又称互联层）、传输层和应用层，每一层都呼叫它的下一层所提供的网络来完成自己的需求。</span><br><span class="line">  每一层对应的协议有：</span><br><span class="line">1.网络接口层协议：Ethernet 802.3、Token Ring 802.5、X.25、Frame relay、HDLC、PPP ATM等。</span><br><span class="line">2.网络层协议：IP（Internet Protocol，英特网协议）、ICMP（Internet Control Message Protocol，控制报文协议）、ARP（Address Resolution Protocol，地址转换协议）、RARP（Reverse ARP，反向地址转换协议）。</span><br><span class="line">3.传输层协议： TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram protocol，用户数据报协议）。</span><br><span class="line">4.应用层协议：FTP（File Transfer Protocol，文件传输协议）、TELNET（用户远程登录服务协议）、DNS（Domain Name Service，是域名解析服务）、SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）、NFS（Network File System，网络文件系统）、HTTP（Hypertext Transfer Protocol，超文本传输协议）。</span><br></pre></td></tr></table></figure>

<h5 id="2-协议的分类"><a href="#2-协议的分类" class="headerlink" title="2.协议的分类"></a>2.协议的分类</h5><p><strong>TCP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</span><br></pre></td></tr></table></figure>

<p><strong>UTP</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务</span><br></pre></td></tr></table></figure>

<h4 id="3-网络编程三要素"><a href="#3-网络编程三要素" class="headerlink" title="3.网络编程三要素"></a>3.网络编程三要素</h4><h5 id="1-协议"><a href="#1-协议" class="headerlink" title="1.协议"></a>1.协议</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机网络通信必须必须遵守的规则</span><br></pre></td></tr></table></figure>

<h5 id="2-IP地址"><a href="#2-IP地址" class="headerlink" title="2.IP地址"></a>2.IP地址</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IP地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。</span><br><span class="line">IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-端口号"><a href="#3-端口号" class="headerlink" title="3.端口号"></a>3.端口号</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所谓的端口，就好像是门牌号一样，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端口的，每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。为了对端口进行区分，将每个端口进行了编号，这就是端口号</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.1024之前的端口号我们不能使用，已经被系统分配给已知的网络软件了</span><br><span class="line">2.网络软件的端口号不能重复</span><br><span class="line">3.端口号由两个字节组成，取值范围在0-65535之间</span><br></pre></td></tr></table></figure>

<p><strong>常用的端口号</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.80端口 网络端口 www.baidu.com:80 正确的网址  www.baidu.com:70 错误的网址</span><br><span class="line">2.数据库  mysql：3306   Oracle：1512</span><br><span class="line">3.Tomcat服务器：8080</span><br></pre></td></tr></table></figure>

<h4 id="4-TCP通信程序"><a href="#4-TCP通信程序" class="headerlink" title="4.TCP通信程序"></a>4.TCP通信程序</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP通信能实现两台计算机之间的数据交互，通信的两端，要严格区分为客户端（Client）和服务端（Server）</span><br></pre></td></tr></table></figure>

<p><strong>通信的步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">服务器端先启动</span><br><span class="line">服务器端不会主动请求客户端</span><br><span class="line">必需使用客户端请求服务器端</span><br><span class="line">客户端和服务器端就会建立一个逻辑连接</span><br><span class="line">而这个连接包含一个对象</span><br><span class="line">这个对象就是IO对象</span><br><span class="line">客户端和服务器端就可以使用</span><br><span class="line">IO对象进行通信</span><br><span class="line">通信的数据不仅仅是字符</span><br><span class="line">所以IO对象是字节流对象</span><br></pre></td></tr></table></figure>

<p><strong>服务器必须明确两件事情</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.多个客户端同时和服务器进行交互，服务器必须明确和哪个客户端进行的交互，在服务器端有一个方法，叫accept客户端获取到请求的客户端对象</span><br><span class="line">2.多个客户端同时和服务器端进行交互，就需要使用多个IO流对象</span><br><span class="line">服务器是没有IO流的，服务器可以获取到请求的客户端对象Socket</span><br><span class="line">使用每个客户端Socket中提供的IO流和客户端进行交互</span><br><span class="line">服务器端使用客户端的字节输入流读取客户端发送的数据</span><br><span class="line">服务器端使用客户端的字节输出流给客户端回写数据</span><br><span class="line">简单记：服务器使用客户端的流和客户端交互</span><br></pre></td></tr></table></figure>

<h5 id="2-TCP通信的客户端"><a href="#2-TCP通信的客户端" class="headerlink" title="2.TCP通信的客户端"></a>2.TCP通信的客户端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP通信的客户端:向服务器发送连接请求，给服务器发送数据，读取服务器回写的数据</span><br></pre></td></tr></table></figure>

<p><strong>表示客户端的类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.net.Socket:此类实现客户端套接字（也可以叫&quot;套接字&quot;）。套接字是两台机器间通信的端点</span><br><span class="line">套接字包含了IP地址和端口号的网络单位</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Socket(String host, <span class="keyword">int</span> port) <span class="comment">//创建一个流套接字并将其连接到指定主机上的指定端口号。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*参数：String host：服务器主机的名称/服务器的IP地址</span></span><br><span class="line"><span class="comment">*	  int port：服务器的端口号 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>成员方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="comment">//返回此套接字的输出流。 </span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="comment">//返回此套接字的输入流。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="comment">//关闭此套接字。 </span></span></span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建客户端对象Socket，构造方法中绑定服务器的IP地址和端口号</span><br><span class="line">2.使用Socket对象中的方法getOutputStream获取网络字节输出流OutputStream对象。</span><br><span class="line">3.使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。</span><br><span class="line">4.使用Socket对象中的方法getInputStream获取网络字节输入流InputStream对象</span><br><span class="line">5.使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</span><br><span class="line">6.释放资源（Socket）</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.客户端和服务器进行交互，必须使用Socket中提供的网络流，不能使用自己创建的流对象</span><br><span class="line">2.当我们创建客户端对象Socket的时候，就会去请求服务器和服务器经过三次握手建立连接通路。如果服务器没有启动，那么就会抛出异常</span><br><span class="line">如果服务器已经启动，就可以进行交互了。</span><br></pre></td></tr></table></figure>

<h5 id="3-TCP通信的服务器端"><a href="#3-TCP通信的服务器端" class="headerlink" title="3.TCP通信的服务器端"></a>3.TCP通信的服务器端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP通信的服务器端：接收客户端的请求，读取客户端发送的数据，给客户端回写数据</span><br></pre></td></tr></table></figure>

<p><strong>表示服务器端的类</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.net.ServerSocket</span><br><span class="line">此类实现服务器套接字。服务器套接字等待请求通过网络传入。它基于该请求执行某些操作，然后可能向请求者返回结果。 </span><br><span class="line"></span><br><span class="line">服务器套接字的实际工作由 SocketImpl 类的实例执行。应用程序可以更改创建套接字实现的套接字工厂来配置它自身，从而创建适合本地防火墙的套接字。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>构造方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket(<span class="keyword">int</span> port) <span class="comment">//创建绑定到特定端口的服务器套接字。</span></span><br></pre></td></tr></table></figure>

<p><strong>成员方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Socket accept() //	侦听并接受到此套接字的连接。 </span><br></pre></td></tr></table></figure>

<p><strong>使用步骤</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.创建服务器对象ServerSocket，构造方法中传递端口号</span><br><span class="line">2.使用ServerSocket对象中的accept方法，获取到请求的客户端对象Socket</span><br><span class="line">3.使用Socket对象中的方法getInputStream获取网络字节输入流InputStream</span><br><span class="line">4.使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据 </span><br><span class="line">5.使用Socket对象中的方法getOutputStream获取网络字节输出流OutputStream对象。</span><br><span class="line">6.使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据</span><br><span class="line">7.释放资源（Socket，ServerSocket）</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong></p>
<p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建客户端对象Socket，构造方法中绑定服务器的IP地址和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//2.使用Socket对象中的方法getOutputStream获取网络字节输出流OutputStream对象。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.使用网络字节输出流OutputStream对象中的方法write，给服务器发送数据。</span></span><br><span class="line">        os.write(<span class="string">&quot;你好，服务器&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//4.使用Socket对象中的方法getInputStream获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">//5.使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while((len = inputStream.read(bytes))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(new String(bytes,0,len));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//6.释放资源（Socket）</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建服务器对象ServerSocket，构造方法中传递端口号</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//2.使用ServerSocket对象中的accept方法，获取到请求的客户端对象Socket</span></span><br><span class="line">        Socket socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//3.使用Socket对象中的方法getInputStream获取网络字节输入流InputStream</span></span><br><span class="line">        InputStream inputStream = socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.使用网络字节输入流InputStream对象中的方法read，读取客户端发送的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//        int len = 0;</span></span><br><span class="line"><span class="comment">//        while((len = inputStream.read(bytes))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(new String(bytes,0,len));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">int</span> len = inputStream.read(bytes);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        <span class="comment">//5.使用Socket对象中的方法getOutputStream获取网络字节输出流OutputStream对象。</span></span><br><span class="line">        OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//6.使用网络字节输出流OutputStream对象中的方法write，给客户端回写数据</span></span><br><span class="line">        outputStream.write(<span class="string">&quot;你好，客户端&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//7.释放资源（Socket，ServerSocket）</span></span><br><span class="line">        socket.close();</span><br><span class="line">        serverSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-文件上传案例"><a href="#4-文件上传案例" class="headerlink" title="4.文件上传案例"></a>4.文件上传案例</h5><p><strong>客户端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个本地输入流对象FileInputStream，构造方法中绑定要读取的数据源</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.创建一个客户端对象Socket，构造方法中绑定服务器的IP地址和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//3.使用Socket对象中的方法getOutputStream获取网络字节输出流OutputStream对象。</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//4.使用本地字节输入流FileInputStream对象中的方法read，读取本地文件</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//5.使用网络字节输出流OutputStream对象中的方法write，把读取到的文件上传到服务器。</span></span><br><span class="line">            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 结束标记</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line">        <span class="comment">//6.使用Socket对象中的方法getInputStream获取网络字节输入流InputStream对象</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//7.使用网络字节输入流InputStream对象中的方法read，读取服务器回写的数据</span></span><br><span class="line">        <span class="keyword">while</span>((len = is.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//8.释放资源（Socket FileInputStream）</span></span><br><span class="line">        fis.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务器端</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件上传的服务器端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个服务器ServerSocket对象，和系统指定的端口号</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//2.使用ServerSocket对象中的accept方法，获取到请求的客户端Socket对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        Socket socket = serverSocket.accept();</span><br><span class="line">                        <span class="comment">//3.使用Socket对象中的方法getInputStream，获取到网路字节输入流InputStream对象</span></span><br><span class="line">                        InputStream is = socket.getInputStream();</span><br><span class="line">                        <span class="comment">//4.判断d:\\upload文件夹是否存在，不存在则创建</span></span><br><span class="line">                        File file = <span class="keyword">new</span> File(<span class="string">&quot;d:\\upload&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">                            file.mkdir();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//5.创建一个本地字节输出流FileOutputStream对象，构造方法中绑定要输出的目的地</span></span><br><span class="line">                        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file+<span class="string">&quot;\\1.jpg&quot;</span>);</span><br><span class="line">                        <span class="comment">//6.使用网络字节输入流InputStream对象中的方法read，读取客户端上传的文件</span></span><br><span class="line">                        <span class="keyword">int</span> len =<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">while</span>((len = is.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="comment">//7.使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器的硬盘上</span></span><br><span class="line">                            fos.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//8.使用Socket对象中的方法getOutputStream，获取到网路字节输入流OutputStream对象</span></span><br><span class="line">                        OutputStream os = socket.getOutputStream();</span><br><span class="line">                        <span class="comment">//9.使用网络字节输出流OutputStream对象中的方法write，给客户端回写上传成功</span></span><br><span class="line">                        os.write(<span class="string">&quot;上传成功&quot;</span>.getBytes());</span><br><span class="line">                        <span class="comment">//10.释放资源（FileOutputStream，Socket，ServerSocket）</span></span><br><span class="line">                        fos.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-模拟BS服务器"><a href="#5-模拟BS服务器" class="headerlink" title="5.模拟BS服务器"></a>5.模拟BS服务器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建BS版TCP服务器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSTCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个服务器ServerSocket对象，和系统指定的端口号</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 浏览器解析服务器回写的html页面，页面中有图片，那么浏览器会单独的开启一个线程，读取服务器的文件</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//2.使用ServerSocket对象中的accept方法，获取到请求的浏览器Socket对象</span></span><br><span class="line">                        Socket socket = serverSocket.accept();</span><br><span class="line">                        <span class="comment">//3.使用Socket对象中的方法getInputStream，获取到网路字节输入流InputStream对象</span></span><br><span class="line">                        InputStream is = socket.getInputStream();</span><br><span class="line">                        <span class="comment">//4.把is网络字节输入流对象，转换为字符缓冲流</span></span><br><span class="line"><span class="comment">//                        int len =0;</span></span><br><span class="line"><span class="comment">//                        byte[] bytes = new byte[1024];</span></span><br><span class="line"><span class="comment">//                        while((len = is.read(bytes))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//                            //7.使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器的硬盘上</span></span><br><span class="line"><span class="comment">//                            System.out.println(new String(bytes,0,len));</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line">                        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line">                        <span class="comment">//把客户端请求的第一行读取出来</span></span><br><span class="line">                        String line = br.readLine();</span><br><span class="line">                        <span class="comment">//把读取的信息进行切割,只要中间部分</span></span><br><span class="line">                        String[] str = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                        <span class="comment">//把路径前面的/去掉，进行截取</span></span><br><span class="line">                        String htmlPath = str[<span class="number">1</span>].substring(<span class="number">1</span>);</span><br><span class="line">                        <span class="comment">//创建一个本地字节输入流，构造方法中绑定要读取的html路径</span></span><br><span class="line">                        FileInputStream fis = <span class="keyword">new</span> FileInputStream(htmlPath);</span><br><span class="line">                        <span class="comment">//8.使用Socket对象中的方法getOutputStream，获取到网路字节输入流OutputStream对象</span></span><br><span class="line">                        OutputStream os = socket.getOutputStream();</span><br><span class="line">                        <span class="comment">//写入HTTP协议响应头，固定写法</span></span><br><span class="line">                        os.write(<span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span>.getBytes());</span><br><span class="line">                        os.write(<span class="string">&quot;Content-Type:text/html\r\n&quot;</span>.getBytes());</span><br><span class="line">                        os.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br><span class="line">                        <span class="comment">//一读一写复制文件，把服务器读取的文件回写到客户端</span></span><br><span class="line">                        <span class="keyword">int</span> len =<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                        <span class="keyword">while</span>((len = fis.read(bytes))!=-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="comment">//7.使用本地字节输出流FileOutputStream对象中的方法write，把读取到的文件保存到服务器的硬盘上</span></span><br><span class="line">                            os.write(bytes,<span class="number">0</span>,len);</span><br><span class="line">                        &#125;</span><br><span class="line">                        fis.close();</span><br><span class="line">                        socket.close();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//serverSocket.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十二-函数式接口"><a href="#十二-函数式接口" class="headerlink" title="十二.函数式接口"></a>十二.函数式接口</h3><p><strong>概念</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有且仅有一个抽象方法的接口</span><br></pre></td></tr></table></figure>

<p><strong>格式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 interface 接口名称&#123;</span><br><span class="line">	public abstract 返回值类型 方法名称（可选参数信息）；</span><br><span class="line">	//其他非抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-FunctionInterface注解"><a href="#1-FunctionInterface注解" class="headerlink" title="1.FunctionInterface注解"></a>1.FunctionInterface注解</h4><p><strong>作用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以检测接口是否是一个函数式接口</span><br><span class="line">是：编译成功</span><br><span class="line">否：编译失败（接口中没有抽象方法或者抽象方法个数大于1）</span><br></pre></td></tr></table></figure>

<h4 id="2-函数式编程"><a href="#2-函数式编程" class="headerlink" title="2.函数式编程"></a>2.函数式编程</h4><h5 id="1-lambda的延迟执行"><a href="#1-lambda的延迟执行" class="headerlink" title="1.lambda的延迟执行"></a>1.lambda的延迟执行</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有些场景的代码执行后，结构不一定会被使用，从而造成性能浪费。而lambda表达式时延迟执行的，正好可以作为解决方案，提升性能</span><br></pre></td></tr></table></figure>

<h4 id="3-常用的函数式接口"><a href="#3-常用的函数式接口" class="headerlink" title="3.常用的函数式接口"></a>3.常用的函数式接口</h4><h5 id="1-Supplier"><a href="#1-Supplier" class="headerlink" title="1.Supplier"></a>1.Supplier</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.function Interface Supplier&lt;T&gt;接口仅包含一个无参的方法T get().用来获取一个泛型参数指定类型的对象数据。</span><br><span class="line"></span><br><span class="line">Supplier&lt;T&gt;接口被称之为生产型接口，指定接口的泛型是什么类型，那么接口中get方法就会生产什么类型的数据</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用函数式接口Supplier，查找数组中的最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sup.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">30</span>,<span class="number">5</span>,<span class="number">60</span>,<span class="number">30</span>,<span class="number">100</span>,<span class="number">59</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxValue = getMax(()-&gt;&#123;</span><br><span class="line">            <span class="comment">//定义变量，记录最大值</span></span><br><span class="line">            <span class="keyword">int</span> max=arr[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i&gt;max)&#123;</span><br><span class="line">                    max = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-consumer"><a href="#2-consumer" class="headerlink" title="2.consumer"></a>2.consumer</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.function Interface Consumer&lt;T&gt;</span><br><span class="line">正好和Supplier接口相反，它不是生产一个数据，而是消费一个数据，其数据类型由泛型决定</span><br><span class="line">Consumer接口中包含的抽象方法void accept（T t），意为消费一个指定泛型的数据，至于怎么消费，自定义</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Consumer接口反转输出字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="string">&quot;张三&quot;</span>,(name)-&gt;&#123;</span><br><span class="line">            <span class="comment">//把字符串进行反转输出</span></span><br><span class="line">            String reName = <span class="keyword">new</span> StringBuffer(name).reverse().toString();</span><br><span class="line">            System.out.println(reName);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Concusmer接口的默认方法andThen</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after)返回一个组合的Consumer ， Consumer执行该操作，后跟after操作。 如果执行任一操作会抛出异常，它将被转发到组合操作的调用者。 如果执行此操作抛出一个异常， after操作将不被执行。 </span><br><span class="line">需要两个Consumer接口，可以把两个Consumer接口组合到一起，在对数据进行消费</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDefaultFDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用andThen方法，把两个Consumer接口连接到一起，再消费数据</span></span><br><span class="line">        con1.andThen(con2).accept(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        method(<span class="string">&quot;Hello&quot;</span>,(str)-&gt;System.out.println(str.toLowerCase()),(str)-&gt;System.out.println(str.toUpperCase()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-Predicate"><a href="#3-Predicate" class="headerlink" title="3.Predicate"></a>3.Predicate</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.function Interface Predicate&lt;T&gt;</span><br><span class="line">作用：对某种数据类型的数据进行判断，结果返回一个boolean值</span><br><span class="line">接口中包含一个抽象方法：</span><br><span class="line">boolean test(T t) ：用来对指定数据类型进行判断</span><br><span class="line">结果：符合条件，返回True</span><br><span class="line">	 不符合条件，返回False</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkedString</span><span class="params">(String str, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre.test(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = checkedString(<span class="string">&quot;abcdef&quot;</span>,(str)-&gt;&#123;</span><br><span class="line">            <span class="comment">//判断字符串的长度是否大于5</span></span><br><span class="line">            <span class="keyword">return</span> str.length()&gt;<span class="number">5</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="1-Predicate接口中的默认方法and"><a href="#1-Predicate接口中的默认方法and" class="headerlink" title="1.Predicate接口中的默认方法and"></a>1.Predicate接口中的默认方法and</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate接口中的默认方法and：表并且关系，也可以用于连接两个判断条件</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Predicate方法中的默认方法and</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateAndDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkedString</span><span class="params">(String str, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.and(pre2).test(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = checkedString(<span class="string">&quot;abcde&quot;</span>,(str)-&gt;str.length()&gt;<span class="number">5</span>,(str)-&gt;str.contains(<span class="string">&quot;a&quot;</span>));</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-Predicate接口中的默认方法or"><a href="#2-Predicate接口中的默认方法or" class="headerlink" title="2.Predicate接口中的默认方法or"></a>2.Predicate接口中的默认方法or</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate接口中的默认方法or:表或关系 和and方法用法一样</span><br></pre></td></tr></table></figure>

<h6 id="3-Predicate接口中的默认方法negate"><a href="#3-Predicate接口中的默认方法negate" class="headerlink" title="3.Predicate接口中的默认方法negate"></a>3.Predicate接口中的默认方法negate</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Predicate接口中的默认方法negate:表取反</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateNegateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkedString</span><span class="params">(String str, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre.negate().test(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> b = checkedString(<span class="string">&quot;abcde&quot;</span>,(str)-&gt;str.length()&gt;<span class="number">5</span>);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-Predicate综合案例"><a href="#4-Predicate综合案例" class="headerlink" title="4.Predicate综合案例"></a>4.Predicate综合案例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断给定的数组中，名字长度大于等于4，且性别是女的人</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicatePracticeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(String str, Predicate&lt;String&gt; pre1,Predicate&lt;String&gt; pre2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.and(pre2).test(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;迪丽热巴，女&quot;</span>,<span class="string">&quot;古力娜扎，女&quot;</span>,<span class="string">&quot;马儿扎哈，男&quot;</span>,<span class="string">&quot;赵丽颖，女&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (String message : strings) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> b = check(message,(str)-&gt;&#123;</span><br><span class="line">                String[] name = str.split(<span class="string">&quot;，&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> name[<span class="number">0</span>].length()&gt;=<span class="number">4</span>;</span><br><span class="line">            &#125;,(str)-&gt;&#123;</span><br><span class="line">                String[] sex = str.split(<span class="string">&quot;，&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> sex[<span class="number">1</span>].equals(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">if</span> (b)&#123;</span><br><span class="line">                System.out.println(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Function接口"><a href="#4-Function接口" class="headerlink" title="4.Function接口"></a>4.Function接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.function Interface Function&lt;T,R&gt;</span><br><span class="line">用来根据一个类型的数据得到另一个类型的数据，前者称为前置条件，后者称为后置条件</span><br><span class="line">最主要的抽象方法是：R apply(T t),根据类型T的参数获取类型R的结果</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串转换为int类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">test</span><span class="params">(String str, Function&lt;String,Integer&gt; fun)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = test(<span class="string">&quot;123&quot;</span>,(str)-&gt;Integer.parseInt(str));</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-Function接口中的默认方法andThen"><a href="#1-Function接口中的默认方法andThen" class="headerlink" title="1.Function接口中的默认方法andThen"></a>1.Function接口中的默认方法andThen</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function接口中的默认方法andThen：用来进行组合操作</span><br></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串“123”转换为Integer类型，再+10，再转换为字符串输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionAndThenDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, Function&lt;String,Integer&gt; fun1,Function&lt;Integer,String&gt; fun2)</span> </span>&#123;</span><br><span class="line">        String s = fun1.andThen(fun2).apply(str);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        change(<span class="string">&quot;123&quot;</span>,(str)-&gt;&#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(str)+<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;,(str)-&gt;&#123;</span><br><span class="line">            String s = str.toString();</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十三-Stream流"><a href="#十三-Stream流" class="headerlink" title="十三.Stream流"></a>十三.Stream流</h3><p><strong>概念</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Stream&lt;T&gt; extends BaseStream&lt;T,Stream&lt;T&gt;&gt;</span><br><span class="line">从jdk1.8开始，关注的是做什么，而不是怎么做</span><br><span class="line">1.Stream是元素的集合，这点让Stream看起来用些类似Iterator；</span><br><span class="line">2.可以支持顺序和并行的对原Stream进行汇聚的操作；</span><br><span class="line">大家可以把Stream当成一个高级版本的Iterator。原始版本的Iterator，用户只能一个一个的遍历元素并对其执行某些操作；高级版本的Stream，用户只要给出需要对其包含的元素执行什么操作，比如“过滤掉长度大于10的字符串”、“获取每个字符串的首字母”等，具体这些操作如何应用到每个元素上，就给Stream就好了！</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream流其实是一个集合元素的函数模型，它并不是集合，也不是数据结构，其本身并不存储任何元素（或其地址值）</span><br><span class="line">Stream流是一个来自数据源的元素队列：</span><br><span class="line">1.元素是特定类型的对象，形成一个队列。java中的Stream并不会存储元素，而是按需计算。</span><br><span class="line">2.数据源：流的来源可以是集合、数组等。</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-使用Stream流的方式遍历集合"><a href="#1-使用Stream流的方式遍历集合" class="headerlink" title="1.使用Stream流的方式遍历集合"></a>1.使用Stream流的方式遍历集合</h4><p><strong>案例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Stream流过滤名字长度为2且以张开头的名字，打印输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        list.stream().filter((name)-&gt;name.length()==<span class="number">2</span>)</span><br><span class="line">                .filter((name)-&gt;name.startsWith(<span class="string">&quot;张&quot;</span>))</span><br><span class="line">                .forEach(name-&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-两种获取Stream流的方式"><a href="#2-两种获取Stream流的方式" class="headerlink" title="2.两种获取Stream流的方式"></a>2.两种获取Stream流的方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.所有的Collection集合都可以通过stream默认方法获取流</span><br><span class="line">2.Stream接口的静态方法of可以获取数组对应的流 static &lt;T&gt; Stream&lt;T&gt; of(T... values)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把集合转换为Stream流</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Stream&lt;String&gt; stream1 = set.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Map需要将键与值转换为Collection集合</span></span><br><span class="line">        Map&lt;String,String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; keySet = map.keySet();</span><br><span class="line">        Stream&lt;String&gt; stream2 = keySet.stream();</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        Stream&lt;String&gt; stream3 = values.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取键值对（键与值的映射关系 entrySet）</span></span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        Stream&lt;Map.Entry&lt;String, String&gt;&gt; stream4 = entries.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把数组转换为Stream流</span></span><br><span class="line">        Stream&lt;Integer&gt; stream5 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//可变参数可以传递数组</span></span><br><span class="line">        Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        Stream&lt;Integer&gt; stream6 = Stream.of(arr);</span><br><span class="line">        String[] arr2 = &#123;<span class="string">&quot;123&quot;</span>,<span class="string">&quot;asda&quot;</span>,<span class="string">&quot;ccc&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream7 = Stream.of(arr2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3.常用方法"></a>3.常用方法</h4><h5 id="1-fouEach-逐一处理"><a href="#1-fouEach-逐一处理" class="headerlink" title="1.fouEach(逐一处理)"></a>1.fouEach(逐一处理)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void forEach(Consumer&lt;? super T&gt; action)该方法接收一个Consumer接口，会将每一个流元素交给该函数处理</span><br><span class="line">Consumer接口中包含的抽象方法void accept（T t）</span><br></pre></td></tr></table></figure>

<p><strong>简单记</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">forEach方法，用来遍历流中的数据</span><br><span class="line">是一个终结方法，遍历之后就不能继续调用Stream流中的其他方法</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Stream流属于管道流，只能被消费一次</span><br><span class="line">第一个Stream流调用完毕方法，数据就会流转到下一个Stream上，而这时第一个Stream流已经使用完毕，就会关闭，使用第一个Stream流就不能再调用方法了</span><br></pre></td></tr></table></figure>



<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamForEach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个Stream流</span></span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Stream流中的方法forEach对Stream流中的数据进行遍历</span></span><br><span class="line">        stream.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-filter-过滤"><a href="#2-filter-过滤" class="headerlink" title="2.filter(过滤)"></a>2.filter(过滤)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)对Stream流中的元素进行过滤</span><br><span class="line">Predicate中的抽象方法boolean test(T t) ：用来对指定数据类型进行判断</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamFilter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        stream.filter(name -&gt; name.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(name-&gt; System.out.println(name));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-map-映射"><a href="#3-map-映射" class="headerlink" title="3.map(映射)"></a>3.map(映射)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</span><br><span class="line">该接口需要一个Function函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流</span><br><span class="line">Function中的抽象方法：</span><br><span class="line">R apply(T t)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将字符串转换为Integer类型输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamMap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>);</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = stream.map((String s) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(s);</span><br><span class="line">        &#125;);</span><br><span class="line">        integerStream.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-count-统计"><a href="#4-count-统计" class="headerlink" title="4.count(统计)"></a>4.count(统计)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long count()：用于统计Stream流中元素的个数</span><br><span class="line">count方法是一个终结方法，返回值是一个long类型的整数</span><br><span class="line">所有不能再继续调用Stream流中的其他方法了</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取Stream流中元素的个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        list.add(<span class="number">5</span>);</span><br><span class="line">        list.add(<span class="number">6</span>);</span><br><span class="line">        list.add(<span class="number">7</span>);</span><br><span class="line">        list.add(<span class="number">8</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">        <span class="keyword">long</span> count = stream.count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-limit-截取"><a href="#5-limit-截取" class="headerlink" title="5.limit(截取)"></a>5.limit(截取)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; limit(long maxSize) 可以对流进行截取，只取用前n个</span><br><span class="line">参数是一个long型，如果集合长度大于参数则进行截取，否则不进行操作</span><br><span class="line">limit方法是一个延迟方法，只是对流中的元素进行截取，返回的是一个新的流，所有可以继续调用Stream流中的其他方法 </span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对字符串数组进行截取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamLimit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;赵六&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        stream.limit(<span class="number">2</span>).forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-skip-跳过"><a href="#6-skip-跳过" class="headerlink" title="6.skip(跳过)"></a>6.skip(跳过)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; skip(long n)用于跳过元素</span><br><span class="line">如果流的当前长度大于n,则跳过前n个,否则将会得到一个长度为0的空流</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamSkip</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳过字符串数组中前两个元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&quot;赵六&quot;</span>&#125;;</span><br><span class="line">        Stream&lt;String&gt; stream = Stream.of(arr);</span><br><span class="line">        stream.skip(<span class="number">2</span>).forEach(name -&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-concat"><a href="#7-concat" class="headerlink" title="7.concat"></a>7.concat</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s):用于把流组合到一起</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamConcat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] arr = &#123;<span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span>,<span class="string">&quot;赵六&quot;</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        list.add(<span class="number">3</span>);</span><br><span class="line">        list.add(<span class="number">4</span>);</span><br><span class="line">        Stream&lt;Integer&gt; stream2 = list.stream();</span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(arr);</span><br><span class="line">        Stream&lt;Serializable&gt; concat = Stream.concat(stream1, stream2);</span><br><span class="line">        concat.forEach(name-&gt; System.out.println(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十四-方法引用"><a href="#十四-方法引用" class="headerlink" title="十四.方法引用"></a>十四.方法引用</h3><h4 id="1-方法引用符"><a href="#1-方法引用符" class="headerlink" title="1.方法引用符"></a>1.方法引用符</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">双冒号::为引用运算符,而它所在的表达式被称为方法引用.如果Lambda要表达的函数方案已经存在于某个方法的实现中,那么则可以通过双冒号来引用该方法作为Lambda的代替者</span><br><span class="line">注意:</span><br><span class="line">Lambda中传递的参数一定是方法中的那个方法可以接收的类型,否则会抛出异常</span><br></pre></td></tr></table></figure>

<h4 id="2-通过对象名引用成员方法"><a href="#2-通过对象名引用成员方法" class="headerlink" title="2.通过对象名引用成员方法"></a>2.通过对象名引用成员方法</h4><p><strong>使用前提</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名已经存在,成员方法也是已经存在,就可以使用对象名引用成员方法</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Printable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRerObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printUpperCaseString</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        System.out.println(s.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoObjectReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printString</span><span class="params">(Printable p)</span></span>&#123;</span><br><span class="line">        p.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        printString((s)-&gt;&#123;</span></span><br><span class="line"><span class="comment">//            MethodRerObject methodRerObject = new MethodRerObject();</span></span><br><span class="line"><span class="comment">//            methodRerObject.printUpperCaseString(s);</span></span><br><span class="line"><span class="comment">//        &#125;);</span></span><br><span class="line"></span><br><span class="line">        MethodRerObject methodRerObject = <span class="keyword">new</span> MethodRerObject();</span><br><span class="line">        printString(methodRerObject::printUpperCaseString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-通过类名引用静态成员方法"><a href="#3-通过类名引用静态成员方法" class="headerlink" title="3.通过类名引用静态成员方法"></a>3.通过类名引用静态成员方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类已经存在,静态成员方法也已经存在,就可以通过类名直接引用静态成员方法</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calcable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calcAbs</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodStaticObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> n,Calcable c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c.calcAbs(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = method(-<span class="number">10</span>,(n)-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(n);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        <span class="comment">//使用方法引用优化Lambda</span></span><br><span class="line">        <span class="keyword">int</span> num2 = method(-<span class="number">10</span>,Math::abs);</span><br><span class="line">        System.out.println(num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="十五-Junit"><a href="#十五-Junit" class="headerlink" title="十五.Junit"></a>十五.Junit</h3><h4 id="1-测试分类"><a href="#1-测试分类" class="headerlink" title="1.测试分类"></a>1.测试分类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">黑盒测试:不需要写代码,给输入值,看程序是否能够输出期望的值.</span><br><span class="line">白盒测试:需要写代码,关注程序具体的执行流程</span><br></pre></td></tr></table></figure>

<h4 id="2-使用步骤"><a href="#2-使用步骤" class="headerlink" title="2.使用步骤"></a>2.使用步骤</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.定义一个测试类(测试用例)</span><br><span class="line">建议:</span><br><span class="line">	测试类名:被测试的类名Test  ****Test</span><br><span class="line">	包名:***.***.**.test </span><br><span class="line">2.定义测试的方法:可以独立运行</span><br><span class="line">建议:</span><br><span class="line">	方法名:test测试的方法名 testAdd()</span><br><span class="line">	返回值:void</span><br><span class="line">	参数列表:空参</span><br><span class="line">3.给方法加@Test</span><br><span class="line">4.导入junit依赖环境</span><br><span class="line">判定结果</span><br><span class="line">红色:失败</span><br><span class="line">绿色:成功</span><br><span class="line">一般会使用断言操作来处理结果</span><br><span class="line">Assert.assertEquals(期望的结果,程序真实的结果)</span><br></pre></td></tr></table></figure>

<h4 id="3-before-amp-after"><a href="#3-before-amp-after" class="headerlink" title="3.@before&amp;@after"></a>3.@before&amp;@after</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@before:修饰的方法会在测试方法之前执行</span><br><span class="line">@after:修饰的方法会在测试方法之后执行</span><br></pre></td></tr></table></figure>

<h3 id="十六-反射"><a href="#十六-反射" class="headerlink" title="十六.反射"></a>十六.反射</h3><p><strong>概念</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将类的各个组成部分封装为对象,这就是反射机制</span><br><span class="line">反射:框架设计的灵魂</span><br><span class="line">框架:半成品软件.可以在框架的基础上进行软件开发,简化代码</span><br></pre></td></tr></table></figure>

<p><strong>好处</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.可以在程序运行过程中,操作这些对象.</span><br><span class="line">2.可以解耦,提高程序的可扩展性</span><br></pre></td></tr></table></figure>

<h4 id="获取Class对象的方式"><a href="#获取Class对象的方式" class="headerlink" title="获取Class对象的方式"></a>获取Class对象的方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.Class.forName(&quot;全类名&quot;):将字节码文件加载进内存,返回Class对象.//多用于配置文件,将类名定义在配置文件中.读取文件,加载类</span><br><span class="line">2.类名.class:通过类名的属性class获取.//多用于参数的传递</span><br><span class="line">3.对象.getClass():getClass()方法在Object类中定义.//多用于对象的获取字节码的方式</span><br><span class="line">结论:同一个字节码文件(*.class)在一次程序运行过程中,只会被加载一次,不论通过哪一种方式获取的Class对象都是同一个</span><br></pre></td></tr></table></figure>

<h4 id="Class对象的功能"><a href="#Class对象的功能" class="headerlink" title="Class对象的功能"></a>Class对象的功能</h4><h5 id="1-获取成员变量们"><a href="#1-获取成员变量们" class="headerlink" title="1.获取成员变量们"></a>1.获取成员变量们</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> <span class="comment">//返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段。 </span></span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span> 返回一个包含某些 Field 对象的数组，这些对象反映此 Class 对象所表示的类或接口的所有可访问公共字段。 </span></span><br></pre></td></tr></table></figure>

<h5 id="2-获取构造方法们"><a href="#2-获取构造方法们" class="headerlink" title="2.获取构造方法们"></a>2.获取构造方法们</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//返回一个 Constructor 对象，它反映此 Class 对象所表示的类的指定公共构造方法。 </span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span> <span class="comment">//返回一个包含某些 Constructor 对象的数组，这些对象反映此 Class 对象所表示的类的所有公共构造方法。 </span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//返回一个 Constructor 对象，该对象反映此 Class 对象所表示的类或接口的指定构造方法。 </span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> <span class="comment">//返回 Constructor 对象的一个数组，这些对象反映此 Class 对象表示的类声明的所有构造方法。 </span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-获取成员方法们"><a href="#3-获取成员方法们" class="headerlink" title="3.获取成员方法们"></a>3.获取成员方法们</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。 </span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> <span class="comment">//返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。 </span></span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//返回一个 Method 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。 </span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> <span class="comment">//返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。 </span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h5 id="4-获取类名"><a href="#4-获取类名" class="headerlink" title="4.获取类名"></a>4.获取类名</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> <span class="comment">//以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。 </span></span></span><br></pre></td></tr></table></figure>

<h3 id="十七-注解"><a href="#十七-注解" class="headerlink" title="十七.注解"></a>十七.注解</h3><p><strong>定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</span><br><span class="line">Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</span><br></pre></td></tr></table></figure>

<p><strong>内置的注解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</span><br></pre></td></tr></table></figure>

<p><strong>作用在代码的注解是</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</span><br><span class="line">@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</span><br><span class="line">@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</span><br></pre></td></tr></table></figure>

<p>作用在其他注解的注解(或者说 元注解)是:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</span><br><span class="line">@Documented - 标记这些注解是否包含在用户文档中。</span><br><span class="line">@Target - 标记这个注解应该是哪种 Java 成员。</span><br><span class="line">@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</span><br></pre></td></tr></table></figure>

<p>从 Java 7 开始，额外添加了 3 个注解:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</span><br><span class="line">@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</span><br><span class="line">@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</span><br></pre></td></tr></table></figure>



<h3 id=""><a href="#" class="headerlink" title=""></a></h3>
    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/hexo/2020/01/17/markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/" rel="prev" title="markdown常用语法">
                  <i class="fa fa-chevron-left"></i> markdown常用语法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/hexo/2021/04/12/JDBC/" rel="next" title="JDBC">
                  JDBC <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jiang Fan</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/hexo/js/comments.js"></script><script src="/hexo/js/utils.js"></script><script src="/hexo/js/motion.js"></script><script src="/hexo/js/next-boot.js"></script>

  






  





</body>
</html>
